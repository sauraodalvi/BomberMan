<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="description"
    content="Play Multiplayer Bomberman online! Battle against friends in this fast-paced 1v1 PvP web game." />
  <link rel="canonical" href="https://sauraodalvi.github.io/BombBattle/multiplayer.html" />

  <!-- Open Graph -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Bomberman Multiplayer PvP" />
  <meta property="og:description" content="Challenge your friends in real-time Bomberman PvP battles." />
  <meta property="og:image" content="https://sauraodalvi.github.io/BombBattle/og-image.png" />
  <meta property="og:url" content="https://sauraodalvi.github.io/BombBattle/multiplayer.html" />
  <title>Bomberman (Phaser 3) - Stage 1</title>
  <style>
    :root {
      --ad-width: 200px;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b0f1a;
      overflow: hidden;
    }

    #app {
      height: 100%;
      height: 100dvh;
      width: 100%;
      display: flex;
      flex-direction: row;
    }

    .ad-slot {
      width: var(--ad-width);
      min-width: var(--ad-width);
      max-width: var(--ad-width);
      flex: 0 0 var(--ad-width);
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.8);
      background: linear-gradient(180deg, #141a2a, #0d1220);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
      border-right: 1px solid rgba(0, 0, 0, 0.35);
      box-sizing: border-box;
      user-select: none;
    }

    #game-wrap {
      flex: 1;
      min-width: 1px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(1200px 800px at 50% 40%, rgba(88, 156, 255, 0.18), rgba(7, 10, 18, 0.95));
      position: relative;
      overflow: hidden;
    }

    #game-container {
      width: 100%;
      height: 100%;
      min-width: 1px;
      min-height: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Ensure canvas stays crisp and centered */
    canvas {
      display: block;
      image-rendering: auto;
      max-width: 100%;
      max-height: 100%;
    }

    @media (max-width: 520px) {
      :root {
        --ad-width: 200px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="ad-left" class="ad-slot">Left Ad (200px)</div>
    <div id="game-wrap">
      <div id="game-container"></div>
    </div>
    <div id="ad-right" class="ad-slot">Right Ad (200px)</div>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script>
    const GRID_SIZE = 13;
    const TILE_SIZE = 48;
    const WORLD_W = GRID_SIZE * TILE_SIZE;
    const WORLD_H = GRID_SIZE * TILE_SIZE;

    function tileToWorldCenter(tileX, tileY) {
      return {
        x: tileX * TILE_SIZE + TILE_SIZE / 2,
        y: tileY * TILE_SIZE + TILE_SIZE / 2,
      };
    }

    function worldToTile(worldX, worldY) {
      return {
        tileX: Phaser.Math.Clamp(Math.floor(worldX / TILE_SIZE), 0, GRID_SIZE - 1),
        tileY: Phaser.Math.Clamp(Math.floor(worldY / TILE_SIZE), 0, GRID_SIZE - 1),
      };
    }

    function isIndestructibleWall(tileX, tileY) {
      const max = GRID_SIZE - 1;
      if (tileX === 0 || tileY === 0 || tileX === max || tileY === max) return true;
      if (tileX % 2 === 0 && tileY % 2 === 0) return true;
      return false;
    }

    function isSpawnSafe(tileX, tileY) {
      // Player spawn at (1,1) with two adjacent safe tiles.
      if (tileX === 1 && tileY === 1) return true;
      if (tileX === 1 && tileY === 2) return true;
      if (tileX === 2 && tileY === 1) return true;
      return false;
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
      }

      spawnEnemies() {
        // Spawn 2-4 enemies in safe corners (not overlapping player).
        const corners = [
          { x: GRID_SIZE - 2, y: 1 },
          { x: 1, y: GRID_SIZE - 2 },
          { x: GRID_SIZE - 2, y: GRID_SIZE - 2 },
          { x: 1, y: 1 },
        ];

        // Never spawn on player's exact tile.
        const filtered = corners.filter(c => !(c.x === this.playerTileX && c.y === this.playerTileY));
        Phaser.Utils.Array.Shuffle(filtered);

        const enemyCount = Phaser.Math.Between(2, 4);
        const spawnList = filtered.slice(0, enemyCount);

        for (const s of spawnList) {
          // If a destructible block is occupying the spawn, clear it.
          if (this.blockByTile.has(`${s.x},${s.y}`)) {
            this.destroyBlockAt(s.x, s.y);
          }

          const pos = tileToWorldCenter(s.x, s.y);
          const shadow = this.add.image(pos.x, pos.y + 14, 'shadow');
          shadow.setDepth(2.5);

          const sprite = this.add.sprite(pos.x, pos.y, 'enemy');
          sprite.setDepth(3);
          sprite.play('enemy-idle');

          this.enemies.push({
            sprite,
            shadow,
            tileX: s.x,
            tileY: s.y,
            isMoving: false,
            dir: Phaser.Math.RND.pick(['left', 'right', 'up', 'down']),
            dead: false,
            moveMs: 140,
          });
        }
      }

      updateEnemies() {
        for (const e of this.enemies) {
          if (!e || e.dead) continue;

          // Update shadow follow in case of tween drift.
          e.shadow.x = e.sprite.x;
          e.shadow.y = e.sprite.y + 14;

          // Contact damage (tile overlap)
          if (!this.isInvulnerable && e.tileX === this.playerTileX && e.tileY === this.playerTileY) {
            this.damagePlayer();
          }

          if (e.isMoving) continue;

          // Try to continue in same direction; if blocked, pick a new one.
          const attemptDirs = this.getEnemyAttemptDirs(e.dir);
          let moved = false;
          for (const dir of attemptDirs) {
            const d = this.dirToDelta(dir);
            const nx = e.tileX + d.dx;
            const ny = e.tileY + d.dy;
            if (this.isTileWalkableForEnemy(nx, ny)) {
              e.dir = dir;
              this.moveEnemyToTile(e, nx, ny);
              moved = true;
              break;
            }
          }

          if (!moved) {
            // stuck; randomize direction for next tick
            e.dir = Phaser.Math.RND.pick(['left', 'right', 'up', 'down']);
          }
        }
      }

      getEnemyAttemptDirs(primaryDir) {
        const dirs = ['left', 'right', 'up', 'down'];
        const rest = dirs.filter(d => d !== primaryDir);
        Phaser.Utils.Array.Shuffle(rest);
        return [primaryDir, ...rest];
      }

      dirToDelta(dir) {
        if (dir === 'left') return { dx: -1, dy: 0 };
        if (dir === 'right') return { dx: 1, dy: 0 };
        if (dir === 'up') return { dx: 0, dy: -1 };
        return { dx: 0, dy: 1 };
      }

      isTileWalkableForEnemy(tileX, tileY) {
        if (tileX < 0 || tileY < 0 || tileX >= GRID_SIZE || tileY >= GRID_SIZE) return false;
        if (isIndestructibleWall(tileX, tileY)) return false;
        if (this.blockByTile.has(`${tileX},${tileY}`)) return false;

        // Enemies treat any bomb as solid (even unarmed) to avoid camping it.
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tileX && b.tileY === tileY) return false;
        }

        // Avoid other enemies
        for (const other of this.enemies) {
          if (!other.dead && other.tileX === tileX && other.tileY === tileY) return false;
        }

        return true;
      }

      moveEnemyToTile(enemy, tileX, tileY) {
        enemy.isMoving = true;
        const to = tileToWorldCenter(tileX, tileY);

        this.tweens.add({
          targets: [enemy.sprite, enemy.shadow],
          x: to.x,
          y: (target) => (target === enemy.shadow ? to.y + 14 : to.y),
          duration: enemy.moveMs,
          ease: 'Linear',
          onComplete: () => {
            enemy.tileX = tileX;
            enemy.tileY = tileY;
            enemy.isMoving = false;

            // Check immediate contact after moving.
            if (!this.isInvulnerable && enemy.tileX === this.playerTileX && enemy.tileY === this.playerTileY) {
              this.damagePlayer();
            }
          }
        });
      }

      preload() {
        // Stage 1 uses generated textures (placeholders). No external assets required.
      }

      create() {
        this.createTextures();

        this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);

        // Stage 6 UI overlay
        if (!this.scene.isActive('UIScene')) {
          this.scene.launch('UIScene');
        }
        this.scene.bringToTop('UIScene');

        this.floorImages = [];
        this.walls = this.physics.add.staticGroup();
        this.blocks = this.physics.add.staticGroup();
        this.blockByTile = new Map();

        this.bombs = this.physics.add.staticGroup();
        this.activeBombs = []; // Local ref to all bombs for rendering

        this.explosions = this.add.group();

        // Players map: id -> { sprite, shadow, ... }
        this.otherPlayers = {};
        this.myId = null;
        this.myPlayer = null; // Ref to my sprite logic

        this.particles = this.add.particles(0, 0, 'particle');
        this.particles.setDepth(50);
        this.debrisParticles = this.add.particles(0, 0, 'debris-1');
        this.debrisParticles.setDepth(49);
        this.vignette = this.add.image(WORLD_W / 2, WORLD_H / 2, 'vignette').setDepth(100).setScrollFactor(0);

        // Keys
        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('W,A,S,D');
        this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.input.keyboard.addCapture('SPACE,W,A,S,D');

        // Socket.io Setup
        const url = (window.location.protocol === 'file:' || window.location.port !== '3000')
          ? 'http://localhost:3000'
          : undefined;
        this.socket = io(url);

        this.socket.on('init', (data) => this.onInit(data));
        this.socket.on('playerJoined', (p) => this.onPlayerJoined(p));
        this.socket.on('playerMoved', (p) => this.onPlayerMoved(p));
        this.socket.on('playerLeft', (id) => this.onPlayerLeft(id));
        this.socket.on('bombPlaced', (b) => this.onBombPlaced(b));
        this.socket.on('bombExploded', (d) => this.onBombExploded(d));
        this.socket.on('playerKilled', (id) => this.onPlayerKilled(id));
        this.socket.on('powerupSpawned', (d) => this.onPowerupSpawned(d));
        this.socket.on('powerupCollected', (d) => this.onPowerupCollected(d));

        this.activePowerups = []; // {id, x, y, sprite, shadow, type}

        // Waiting text
        this.waitingText = this.add.text(WORLD_W / 2, WORLD_H / 2, 'Connecting...', {
          fontSize: '24px', color: '#ffffff'
        }).setOrigin(0.5);
      }

      onInit(data) {
        this.waitingText.destroy();
        this.myId = data.myId;

        // Build Map
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const val = data.map[y][x];
            const pos = tileToWorldCenter(x, y);

            // Floor
            const f = this.add.image(pos.x, pos.y, 'floor').setDepth(0);
            this.floorImages.push(f);

            if (val === 1) {
              this.walls.create(pos.x, pos.y, 'wall').setDepth(2);
            } else if (val === 2) {
              const b = this.blocks.create(pos.x, pos.y, 'block').setDepth(2);
              this.blockByTile.set(`${x},${y}`, { sprite: b, tileX: x, tileY: y });
            }
          }
        }

        // Init Players
        Object.values(data.players).forEach(p => this.createPlayerOne(p));

        // Camera
        if (this.myId && this.otherPlayers[this.myId]) {
          this.myPlayer = this.otherPlayers[this.myId];
          this.cameras.main.startFollow(this.myPlayer.sprite);
        }
      }

      createPlayerOne(pData) {
        if (this.otherPlayers[pData.id]) return;

        const pos = tileToWorldCenter(pData.x, pData.y);
        const shadow = this.add.image(pos.x, pos.y + 14, 'shadow').setDepth(2.5);
        const sprite = this.add.sprite(pos.x, pos.y, 'player').setDepth(3);

        // Tint diff for P2
        if (pData.color === 'red') sprite.setTint(0xffaaaa);

        this.otherPlayers[pData.id] = {
          id: pData.id,
          sprite: sprite,
          shadow: shadow,
          tileX: pData.x,
          tileY: pData.y,
          isMoving: false,
          lastDir: 'down'
        };
      }

      onPlayerJoined(p) {
        this.createPlayerOne(p);
      }

      onPlayerMoved(data) {
        const p = this.otherPlayers[data.id];
        if (!p) return;

        // If it's ME, I might have already moved locally (prediction).
        // For simple sync, we can just correct if diff is large, or ignore if it's me.
        if (data.id === this.myId) return;

        // Tween other player
        const to = tileToWorldCenter(data.x, data.y);
        p.tileX = data.x;
        p.tileY = data.y;

        // Anim
        const dir = data.dir || 'down';
        p.sprite.anims.play('walk-' + dir, true);

        this.tweens.add({
          targets: [p.sprite, p.shadow],
          x: to.x,
          y: (t) => (t === p.shadow ? to.y + 14 : to.y),
          duration: 120,
          onComplete: () => {
            p.sprite.anims.stop();
            p.sprite.setFrame(this.getIdleFrameForDir(dir));
          }
        });
      }

      onPlayerLeft(id) {
        const p = this.otherPlayers[id];
        if (p) {
          p.sprite.destroy();
          p.shadow.destroy();
          delete this.otherPlayers[id];
        }
      }

      onBombPlaced(data) {
        const pos = tileToWorldCenter(data.x, data.y);
        const bombSprite = this.bombs.create(pos.x, pos.y, 'bomb').setDepth(2.8);

        // Fuse anim
        this.tweens.add({
          targets: bombSprite,
          scale: { from: 1, to: 1.08 },
          duration: 220,
          yoyo: true,
          repeat: -1
        });

        // Stage 7 Glow
        const glow = this.add.image(pos.x, pos.y + 2, 'soft-glow').setDepth(2.7).setTint(0xff6b4f).setAlpha(0.6).setScale(1.2);
        this.tweens.add({
          targets: glow, alpha: 0.2, scale: 1.5, duration: 500, yoyo: true, repeat: -1
        });

        this.activeBombs.push({ id: data.id, sprite: bombSprite, glow: glow, x: data.x, y: data.y });
      }

      onBombExploded(data) {
        // Find bomb
        const idx = this.activeBombs.findIndex(b => b.id === data.id);
        if (idx !== -1) {
          const b = this.activeBombs[idx];
          b.sprite.destroy();
          b.glow.destroy();
          this.activeBombs.splice(idx, 1);
        }

        // Cam Shake
        this.cameras.main.shake(120, 0.006);

        // Visuals
        data.tiles.forEach(t => {
          const pos = tileToWorldCenter(t.x, t.y);
          const exp = this.add.image(pos.x, pos.y, 'explosion').setDepth(10);
          this.tweens.add({
            targets: exp, alpha: 0, scale: 1.35, duration: 250, onComplete: () => exp.destroy()
          });
          this.emitExplosionParticles(pos.x, pos.y);
        });

        // Destroy blocks
        data.destroyedBlocks.forEach(b => {
          this.destroyBlockAt(b.x, b.y);
        });
      }

      onPlayerKilled(id) {
        const p = this.otherPlayers[id];
        if (!p) return;

        this.emitEnemyDeathParticles(p.sprite.x, p.sprite.y); // reuse death effect

        this.tweens.add({
          targets: [p.sprite, p.shadow],
          alpha: 0, scale: 0.6, duration: 200,
          onComplete: () => {
            p.sprite.visible = false;
            p.shadow.visible = false;
          }
        });

        if (id === this.myId) {
          // I died
          this.add.text(WORLD_W / 2, WORLD_H / 2, 'GAME OVER', { fontSize: '40px', color: 'red', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5).setDepth(200);
        }
      }

      update() {
        if (!this.myId || !this.myPlayer) return;

        const p = this.myPlayer;
        if (p.isMoving) return; // Wait for tween

        const left = (this.cursors.left.isDown || this.keys.A.isDown);
        const right = (this.cursors.right.isDown || this.keys.D.isDown);
        const up = (this.cursors.up.isDown || this.keys.W.isDown);
        const down = (this.cursors.down.isDown || this.keys.S.isDown);

        let dx = 0;
        let dy = 0;
        let dir = null;

        if (left) { dx = -1; dy = 0; dir = 'left'; }
        else if (right) { dx = 1; dy = 0; dir = 'right'; }
        else if (up) { dx = 0; dy = -1; dir = 'up'; }
        else if (down) { dx = 0; dy = 1; dir = 'down'; }

        if (dir) {
          this.tryMoveByTile(dx, dy, dir);
        } else {
          // Idle
          p.sprite.anims.stop();
          p.sprite.setFrame(this.getIdleFrameForDir(p.lastDir));
        }

        if (Phaser.Input.Keyboard.JustDown(this.spaceKey)) this.tryPlaceBomb();
      }

      tryMoveByTile(dx, dy, dir) {
        const p = this.myPlayer;
        const nx = p.tileX + dx;
        const ny = p.tileY + dy;

        if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) return;
        if (!this.isTileWalkable(nx, ny)) return;

        p.isMoving = true;
        p.lastDir = dir;
        const to = tileToWorldCenter(nx, ny);

        p.sprite.anims.play('walk-' + dir, true);

        // Optimistic update
        this.tweens.add({
          targets: [p.sprite, p.shadow],
          x: to.x,
          y: (t) => (t === p.shadow ? to.y + 14 : to.y),
          duration: 120, // fixed 120ms
          onComplete: () => {
            p.tileX = nx;
            p.tileY = ny;
            p.isMoving = false;

            // Check for powerup
            this.checkForPowerup(nx, ny);
          }
        });

        // Notify Server
        this.socket.emit('move', { x: nx, y: ny, dir: dir });
      }

      isTileWalkable(tileX, tileY) {
        if (isIndestructibleWall(tileX, tileY)) return false;
        if (this.blockByTile.has(`${tileX},${tileY}`)) return false;

        // Bombs blocked (server handles detailed collision, but simple client check prevents visible overlap)
        return true;
      }

      getIdleFrameForDir(dir) {
        const idxByDir = { down: 0, left: 4, right: 8, up: 12 };
        return idxByDir[dir] ?? 0;
      }

      tryPlaceBomb() {
        if (!this.myPlayer) return;
        const p = this.myPlayer;

        // Rate limit: count bombs I own in activeBombs? 
        // For now, let server validate max bombs (although we aren't tracking owner fully in client activeBombs list yet).
        // Sending request...
        this.socket.emit('placeBomb', { x: p.tileX, y: p.tileY });
      }

      setDebug(msg) {
        // Debug UI removed; keep method for non-disruptive internal logging if needed later.
      }

      explodeBomb(bomb) {
        if (!bomb || bomb.exploded) return;
        bomb.exploded = true;

        const bombSprite = bomb.sprite;
        if (bombSprite && bombSprite.active) {
          this.tweens.killTweensOf(bombSprite);
          bombSprite.destroy();
        }

        if (bomb.glow) {
          this.tweens.killTweensOf(bomb.glow);
          bomb.glow.destroy();
        }

        const tiles = this.getExplosionTiles(bomb.tileX, bomb.tileY, this.blastRadius);

        this.cameras.main.shake(120, 0.006);

        for (const t of tiles) {
          const pos = tileToWorldCenter(t.tileX, t.tileY);

          const exp = this.add.image(pos.x, pos.y, 'explosion');
          exp.setBlendMode(Phaser.BlendModes.ADD);
          exp.setDepth(10);
          this.explosions.add(exp);

          this.tweens.add({
            targets: exp,
            alpha: { from: 0.95, to: 0 },
            scale: { from: 0.9, to: 1.35 },
            duration: 260,
            ease: 'Quad.easeOut',
            onComplete: () => exp.destroy(),
          });

          this.emitExplosionParticles(pos.x, pos.y);

          if (t.hitBlock) {
            this.destroyBlockAt(t.tileX, t.tileY);
          }

          this.killEnemiesAtTile(t.tileX, t.tileY);
        }

        this.checkPlayerDamage(tiles);
      }



      emitEnemyDeathParticles(x, y) {
        this.particles.emitParticleAt(x, y, {
          quantity: 16,
          lifespan: { min: 220, max: 520 },
          speed: { min: 40, max: 180 },
          scale: { start: 0.9, end: 0 },
          alpha: { start: 0.85, end: 0 },
          tint: [0x7ce6ff, 0xffd36b, 0xffffff],
          blendMode: 'ADD',
        });

        this.particles.emitParticleAt(x, y, {
          quantity: 6,
          lifespan: { min: 500, max: 950 },
          speed: { min: 12, max: 60 },
          scale: { start: 1.1, end: 1.9 },
          alpha: { start: 0.16, end: 0 },
          tint: 0x9aa7bd,
          blendMode: 'NORMAL',
        });
      }

      getExplosionTiles(originX, originY, radius) {
        const out = [];
        out.push({ tileX: originX, tileY: originY, hitBlock: false });

        const dirs = [
          { dx: 1, dy: 0 },
          { dx: -1, dy: 0 },
          { dx: 0, dy: 1 },
          { dx: 0, dy: -1 },
        ];

        for (const d of dirs) {
          for (let i = 1; i <= radius; i++) {
            const tx = originX + d.dx * i;
            const ty = originY + d.dy * i;
            if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) break;
            if (isIndestructibleWall(tx, ty)) break;

            const key = `${tx},${ty}`;
            if (this.blockByTile.has(key)) {
              out.push({ tileX: tx, tileY: ty, hitBlock: true });
              break;
            }

            out.push({ tileX: tx, tileY: ty, hitBlock: false });
          }
        }

        return out;
      }

      destroyBlockAt(tileX, tileY) {
        const key = `${tileX},${tileY}`;
        const block = this.blockByTile.get(key);
        if (!block || !block.sprite || !block.sprite.active) return;

        const s = block.sprite;
        this.blockByTile.delete(key);

        this.tweens.add({
          targets: s,
          x: s.x + Phaser.Math.Between(-3, 3),
          y: s.y + Phaser.Math.Between(-3, 3),
          duration: 60,
          yoyo: true,
          repeat: 2,
        });

        this.tweens.add({
          targets: s,
          alpha: { from: 1, to: 0 },
          scale: { from: 1, to: 0.6 },
          duration: 220,
          ease: 'Quad.easeIn',
          onComplete: () => {
            s.destroy();
          },
        });

        this.score += 10;
        this.emitUiState();

        // Stage 7: Debris
        const worldPos = tileToWorldCenter(tileX, tileY);
        this.emitBlockDebris(worldPos.x, worldPos.y);

        // Powerups handled by server event
      }

      emitBlockDebris(x, y) {
        // Emit main chunks
        this.debrisParticles.setTexture('debris-1');
        this.debrisParticles.emitParticleAt(x, y, {
          speed: { min: 50, max: 150 },
          angle: { min: 0, max: 360 },
          scale: { start: 1, end: 0.5 },
          alpha: { start: 1, end: 0 },
          lifespan: 600,
          gravityY: 200,
          quantity: 4,
          rotate: { min: 0, max: 360, end: 720 }
        });

        // Emit smaller bits
        this.debrisParticles.setTexture('debris-2');
        this.debrisParticles.emitParticleAt(x, y, {
          speed: { min: 80, max: 200 },
          angle: { min: 0, max: 360 },
          scale: { start: 1, end: 0 },
          lifespan: 400,
          gravityY: 100,
          quantity: 6,
          rotate: { min: 0, max: 360 }
        });
      }

      onPowerupSpawned(data) {
        const pos = tileToWorldCenter(data.x, data.y);
        const shadow = this.add.image(pos.x, pos.y + 14, 'shadow').setDepth(2.55);

        const key = data.type === 'bomb' ? 'powerup-bomb' : data.type === 'radius' ? 'powerup-radius' : 'powerup-speed';
        const sprite = this.add.image(pos.x, pos.y, key).setDepth(3.1);

        // Float
        this.tweens.add({
          targets: sprite, y: pos.y + 2, duration: 700, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
        });

        this.activePowerups.push({ id: data.id, x: data.x, y: data.y, sprite, shadow, type: data.type });
      }

      checkForPowerup(tx, ty) {
        const p = this.activePowerups.find(pu => pu.x === tx && pu.y === ty);
        if (p) {
          this.socket.emit('collectPowerup', p.id);
        }
      }

      onPowerupCollected(data) {
        const idx = this.activePowerups.findIndex(p => p.id === data.id);
        if (idx !== -1) {
          const pu = this.activePowerups[idx];

          // Effect
          this.particles.emitParticleAt(pu.sprite.x, pu.sprite.y, {
            speed: { min: 50, max: 150 }, scale: { start: 1, end: 0 }, lifespan: 400, blendMode: 'ADD'
          });

          pu.sprite.destroy();
          pu.shadow.destroy();
          this.activePowerups.splice(idx, 1);

          // Update UI if it's me
          if (data.playerId === this.myId) {
            if (data.type === 'bomb') this.maxBombs++;
            if (data.type === 'radius') this.blastRadius++;
            this.emitUiState();
          }
        }
      }

      onPlayerKilled(id) {
        const p = this.otherPlayers[id];
        if (!p) return;

        this.emitEnemyDeathParticles(p.sprite.x, p.sprite.y);

        this.tweens.add({
          targets: [p.sprite, p.shadow],
          alpha: 0, scale: 0.6, duration: 200,
          onComplete: () => {
            p.sprite.visible = false;
            p.shadow.visible = false;
          }
        });

        if (id === this.myId) {
          this.add.text(WORLD_W / 2, WORLD_H / 2, 'GAME OVER', { fontSize: '40px', color: 'red', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5).setDepth(200);
          this.myPlayer.alive = false; // Stop input
        }
      }


      emitUiState() {
        if (!this.game || !this.game.events) return;
        this.game.events.emit('ui:update', {
          lives: this.lives,
          score: this.score,
          maxBombs: this.maxBombs,
          blastRadius: this.blastRadius,
          speed: Math.round(1000 / this.tileMoveMs),
        });
      }

      emitExplosionParticles(x, y) {
        // Fire/sparks burst
        this.particles.emitParticleAt(x, y, {
          quantity: 14,
          lifespan: { min: 180, max: 420 },
          speed: { min: 40, max: 170 },
          scale: { start: 0.8, end: 0 },
          alpha: { start: 0.9, end: 0 },
          tint: [0xffd36b, 0xff6b4f, 0xffffff],
          blendMode: 'ADD',
        });

        // Smoke puff
        this.particles.emitParticleAt(x, y, {
          quantity: 6,
          lifespan: { min: 500, max: 900 },
          speed: { min: 15, max: 55 },
          scale: { start: 1.1, end: 1.8 },
          alpha: { start: 0.18, end: 0 },
          tint: 0x9aa7bd,
          blendMode: 'NORMAL',
        });
      }

      createTextures() {
        // Floor
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x162033, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 6);
          g.fillStyle(0x1f2d47, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 8, 6);
          g.fillStyle(0x0b0f1a, 0.25);
          g.fillRect(0, TILE_SIZE - 6, TILE_SIZE, 6);
          g.generateTexture('floor', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        // Indestructible Wall
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x3e4f73, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0x556a93, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 10, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0x6f86b0, 0.55);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('wall', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        // Destructible Block
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x8a5a3c, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0xb3784f, 1);
          g.fillRoundedRect(5, 5, TILE_SIZE - 10, TILE_SIZE - 12, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0xe2b37c, 0.35);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('block', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        // Player placeholder
        {
          // Generate a simple 4x4 spritesheet (16 frames): 4 frames per direction.
          // Frame order: down(0-3), left(4-7), right(8-11), up(12-15)
          const size = TILE_SIZE;
          const sheetKey = 'player-sheet';
          const tex = this.textures.createCanvas(sheetKey, size * 4, size * 4);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size * 4);

          const dirColors = {
            down: { main: '#3ee6a8', edge: 'rgba(182,255,231,0.75)' },
            left: { main: '#4fd0ff', edge: 'rgba(190,240,255,0.75)' },
            right: { main: '#ffb84f', edge: 'rgba(255,236,190,0.75)' },
            up: { main: '#d36bff', edge: 'rgba(245,210,255,0.75)' },
          };

          function drawFrame(frameX, frameY, main, edge, step) {
            const ox = frameX * size;
            const oy = frameY * size;

            // Clear frame
            ctx.clearRect(ox, oy, size, size);

            // Body
            const cx = ox + size / 2;
            const cy = oy + size / 2 - 2;

            // Fake "walk" by shifting feet subtly per frame
            const wobble = (step === 1 ? -2 : step === 3 ? 2 : 0);
            const bob = (step === 2 ? 1 : 0);

            ctx.fillStyle = main;
            roundRect(ctx, cx - 14 + wobble, cy - 16 + bob, 28, 28, 10);
            ctx.fill();

            ctx.strokeStyle = edge;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Simple visor/face
            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8 + wobble, cy - 6 + bob, 16, 6);
          }

          function roundRect(context, x, y, w, h, r) {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          }

          // Build frames
          const dirs = ['down', 'left', 'right', 'up'];
          dirs.forEach((dir, row) => {
            const c = dirColors[dir];
            for (let col = 0; col < 4; col++) {
              drawFrame(col, row, c.main, c.edge, col);
            }
          });

          tex.refresh();

          this.textures.addSpriteSheet('player', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);

          // Animations
          this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }), frameRate: 10, repeat: -1 });
        }

        // Enemy placeholder (simple looping idle)
        {
          const size = TILE_SIZE;
          const sheetKey = 'enemy-sheet';
          const tex = this.textures.createCanvas(sheetKey, size * 4, size);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size);

          function roundRect(context, x, y, w, h, r) {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          }

          for (let i = 0; i < 4; i++) {
            const ox = i * size;
            const cx = ox + size / 2;
            const cy = size / 2 - 2;
            const bob = (i === 1 ? 1 : i === 3 ? -1 : 0);
            const glow = (i === 2 ? 0.85 : 0.65);

            ctx.clearRect(ox, 0, size, size);
            ctx.fillStyle = `rgba(0,0,0,0.22)`;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 28, 14, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#ff4f7e';
            roundRect(ctx, cx - 14, cy - 16 + bob, 28, 28, 10);
            ctx.fill();

            ctx.strokeStyle = `rgba(255,230,240,${glow})`;
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8, cy - 6 + bob, 16, 6);
          }

          tex.refresh();
          this.textures.addSpriteSheet('enemy', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);

          this.anims.create({
            key: 'enemy-idle',
            frames: this.anims.generateFrameNumbers('enemy', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1,
          });
        }

        // Shadow texture (reused for player / later enemies)
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x000000, 0.25);
          g.fillEllipse(TILE_SIZE / 2, TILE_SIZE / 2, 30, 16);
          g.generateTexture('shadow', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        // Bomb texture
        {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x0b0f1a, 0.22);
          g.fillEllipse(size / 2, size / 2 + 14, 30, 16);
          g.fillStyle(0x2b2f3a, 1);
          g.fillCircle(size / 2, size / 2 + 2, 14);
          g.fillStyle(0x495062, 1);
          g.fillCircle(size / 2 - 3, size / 2 - 1, 10);
          g.lineStyle(2, 0xcfd6e6, 0.35);
          g.strokeCircle(size / 2, size / 2 + 2, 14);
          // fuse
          g.lineStyle(3, 0xffc04d, 1);
          g.beginPath();
          g.moveTo(size / 2 + 8, size / 2 - 10);
          g.lineTo(size / 2 + 16, size / 2 - 16);
          g.strokePath();
          g.fillStyle(0xff6b4f, 1);
          g.fillCircle(size / 2 + 16, size / 2 - 16, 3);
          g.generateTexture('bomb', size, size);
          g.destroy();
        }

        // Explosion texture
        {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffd36b, 0.9);
          g.fillCircle(size / 2, size / 2, 10);
          g.fillStyle(0xff6b4f, 0.75);
          g.fillCircle(size / 2, size / 2, 16);
          g.fillStyle(0xffffff, 0.65);
          g.fillCircle(size / 2, size / 2, 6);
          g.generateTexture('explosion', size, size);
          g.destroy();
        }

        // Particle texture
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffffff, 1);
          g.fillCircle(4, 4, 4);
          g.generateTexture('particle', 8, 8);
          g.destroy();
        }

        // Power-up textures
        {
          const size = TILE_SIZE;

          const makeIcon = (key, base, accent, glyph) => {
            const g = this.make.graphics({ x: 0, y: 0, add: false });
            g.fillStyle(0x000000, 0.22);
            g.fillEllipse(size / 2, size / 2 + 14, 26, 14);

            g.fillStyle(base, 1);
            g.fillRoundedRect(size / 2 - 14, size / 2 - 16, 28, 28, 10);
            g.lineStyle(2, accent, 0.8);
            g.strokeRoundedRect(size / 2 - 14, size / 2 - 16, 28, 28, 10);

            g.fillStyle(accent, 1);
            if (glyph === 'B') {
              g.fillCircle(size / 2, size / 2 - 2, 7);
              g.lineStyle(3, accent, 1);
              g.beginPath();
              g.moveTo(size / 2 + 6, size / 2 - 10);
              g.lineTo(size / 2 + 12, size / 2 - 14);
              g.strokePath();
            } else if (glyph === 'R') {
              g.fillCircle(size / 2, size / 2 - 2, 9);
              g.lineStyle(2, 0xffffff, 0.8);
              g.strokeCircle(size / 2, size / 2 - 2, 12);
            } else if (glyph === 'S') {
              g.lineStyle(4, accent, 1);
              g.beginPath();
              g.moveTo(size / 2 - 6, size / 2 + 6);
              g.lineTo(size / 2 + 8, size / 2 - 8);
              g.strokePath();
              g.fillStyle(0xffffff, 0.9);
              g.fillCircle(size / 2 + 8, size / 2 - 8, 3);
            }

            g.generateTexture(key, size, size);
            g.destroy();
          };

          makeIcon('powerup-bomb', 0x1f2d47, 0xffd36b, 'B');
          makeIcon('powerup-radius', 0x223a2a, 0x7ce6ff, 'R');
          makeIcon('powerup-speed', 0x2e1f47, 0xff6b4f, 'S');
        }

        // Stage 7: Debris Particles (Block fragments)
        {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xb3784f, 1);
          g.beginPath();
          g.moveTo(0, 0);
          g.lineTo(6, 2);
          g.lineTo(4, 7);
          g.lineTo(0, 5);
          g.closePath();
          g.fill();
          g.generateTexture('debris-1', 8, 8);
          g.clear();
          g.fillStyle(0x8a5a3c, 1);
          g.fillRect(0, 0, 5, 5);
          g.generateTexture('debris-2', 6, 6);
          g.destroy();
        }

        // Stage 7: Soft Glow (for bombs/powerups)
        {
          const size = 64;
          const canvas = this.textures.createCanvas('soft-glow', size, size);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
          grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, size, size);
          canvas.refresh();
        }

        // Stage 7: Vignette (Atmosphere)
        {
          const w = WORLD_W;
          const h = WORLD_H;
          const canvas = this.textures.createCanvas('vignette', w, h);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.35, w / 2, h / 2, w * 0.85);
          grad.addColorStop(0, 'rgba(0,0,0,0)');
          grad.addColorStop(1, 'rgba(0,2,10,0.6)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);
          canvas.refresh();
        }
      }
    }

    class UIScene extends Phaser.Scene {
      constructor() {
        super({ key: 'UIScene' });
      }

      create() {
        this.score = 0;
        this.lives = 3;
        this.maxBombs = 1;
        this.blastRadius = 2;
        this.speed = 0;

        this.panel = this.add.rectangle(10, 10, 520, 52, 0x0b0f1a, 0.72).setOrigin(0, 0);
        this.panel.setStrokeStyle(1, 0xeaf2ff, 0.12);

        this.scoreText = this.add.text(18, 16, 'Score: 0', { fontSize: '14px', color: '#eaf2ff', fontStyle: '800' });
        this.livesText = this.add.text(18, 36, 'Lives: 3', { fontSize: '12px', color: '#cfe0ff', fontStyle: '600' });

        // Ability icons + values
        this.iconBomb = this.add.image(120, 38, 'powerup-bomb').setScale(0.45).setAlpha(0.95);
        this.iconRadius = this.add.image(210, 38, 'powerup-radius').setScale(0.45).setAlpha(0.95);
        this.iconSpeed = this.add.image(310, 38, 'powerup-speed').setScale(0.45).setAlpha(0.95);
        this.statsText = this.add.text(140, 36, '1     2     0', { fontSize: '12px', color: '#cfe0ff', fontStyle: '800' });

        // Restart button directly under the panel so it is always visible.
        this.restartBtnBg = this.add.rectangle(10, 66, 110, 32, 0xffd36b, 1).setOrigin(0, 0);
        this.restartBtnBg.setStrokeStyle(1, 0xffffff, 0.28);
        this.restartBtnText = this.add.text(10 + 55, 66 + 7, 'Restart', { fontSize: '12px', color: '#0b0f1a', fontStyle: '900' }).setOrigin(0.5, 0);

        this.restartBtnBg.setInteractive({ useHandCursor: true });
        this.restartBtnBg.on('pointerdown', () => this.restartGame());

        // Keep UI fixed to camera.
        this.cameras.main.setScroll(0, 0);

        this._uiHandler = (payload) => this.applyUi(payload);
        this.game.events.on('ui:update', this._uiHandler);

        this.events.once(Phaser.Scenes.Events.SHUTDOWN, () => {
          if (this._uiHandler) this.game.events.off('ui:update', this._uiHandler);
        });

        // Pull initial state if GameScene already exists.
        const gs = this.scene.get('GameScene');
        if (gs && gs.emitUiState) gs.emitUiState();
      }

      applyUi(payload) {
        const prevScore = this.score;
        const prevLives = this.lives;

        this.score = payload.score ?? this.score;
        this.lives = payload.lives ?? this.lives;
        this.maxBombs = payload.maxBombs ?? this.maxBombs;
        this.blastRadius = payload.blastRadius ?? this.blastRadius;
        this.speed = payload.speed ?? this.speed;

        this.scoreText.setText(`Score: ${this.score}`);
        this.livesText.setText(`Lives: ${this.lives}`);
        this.statsText.setText(`${this.maxBombs}     ${this.blastRadius}     ${this.speed}`);

        if (this.score !== prevScore) {
          this.tweens.add({ targets: this.scoreText, scaleX: 1.15, scaleY: 1.15, duration: 90, yoyo: true });
        }
        if (this.lives !== prevLives) {
          this.tweens.add({ targets: [this.livesText, this.panel], alpha: { from: 1, to: 0.6 }, duration: 90, yoyo: true, repeat: 2 });
        }
      }

      restartGame() {
        // Restart gameplay and reset UI values.
        this.score = 0;
        this.lives = 3;
        this.maxBombs = 1;
        this.blastRadius = 2;
        this.speed = 0;
        this.applyUi({ score: 0, lives: 3, maxBombs: 1, blastRadius: 2, speed: 0 });

        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene');
        this.scene.bringToTop('UIScene');
      }
    }

    function getGameParentSize() {
      const el = document.getElementById('game-container');
      const rect = el.getBoundingClientRect();
      return { width: Math.max(1, Math.floor(rect.width)), height: Math.max(1, Math.floor(rect.height)) };
    }

    const initialSize = getGameParentSize();

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      backgroundColor: '#000000',
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false,
        },
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: WORLD_W,
        height: WORLD_H,
      },
      scene: [GameScene, UIScene],
    };

    const game = new Phaser.Game(config);

    // Prevent page scrolling when SPACE is pressed (some browsers still scroll even if Phaser captures).
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') e.preventDefault();
    }, { passive: false });

    // Document-level SPACE fallback (helps when embedded previews/IDEs swallow key events).
    document.addEventListener('keydown', (e) => {
      const isSpace = (e.code === 'Space') || (e.key === ' ') || (e.key === 'Spacebar');
      if (!isSpace) return;
      e.preventDefault();
      if (typeof window.__bmPlaceBomb === 'function') window.__bmPlaceBomb();
    }, { passive: false });

    function handleResize() {
      // Phaser FIT will re-fit into the parent automatically, but it needs a scale refresh.
      if (!game || !game.scale) return;
      game.scale.refresh();
    }

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
  </script>
</body>

</html>