<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Bomberman (Phaser 3) - Stage 1</title>
  <style>
    :root {
      --ad-width: 200px;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b0f1a;
      overflow: hidden;
    }

    #app {
      height: 100%;
      height: 100dvh;
      width: 100%;
      display: flex;
      flex-direction: row;
    }

    .ad-slot {
      width: var(--ad-width);
      min-width: var(--ad-width);
      max-width: var(--ad-width);
      flex: 0 0 var(--ad-width);
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.8);
      background: linear-gradient(180deg, #141a2a, #0d1220);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
      border-right: 1px solid rgba(0, 0, 0, 0.35);
      box-sizing: border-box;
      user-select: none;
    }

    #game-wrap {
      flex: 1;
      min-width: 1px;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(1200px 800px at 50% 40%, rgba(88, 156, 255, 0.18), rgba(7, 10, 18, 0.95));
      position: relative;
      overflow: hidden;
    }

    #game-container {
      width: 100%;
      height: 100%;
      min-width: 1px;
      min-height: 1px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Ensure canvas stays crisp and centered */
    canvas {
      display: block;
      image-rendering: auto;
      max-width: 100%;
      max-height: 100%;
    }

    @media (max-width: 520px) {
      :root {
        --ad-width: 200px;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="ad-left" class="ad-slot">Left Ad (200px)</div>
    <div id="game-wrap">
      <div id="game-container"></div>
    </div>
    <div id="ad-right" class="ad-slot">Right Ad (200px)</div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
    // Simple LCG for seeded random numbers
    class SimpleRNG {
      constructor(seed) { this.state = seed || 1; }
      next() {
        this.state = (this.state * 48271) % 2147483647;
        return (this.state - 1) / 2147483646;
      }
    }

    const GRID_SIZE = 13;
    const TILE_SIZE = 48;
    const WORLD_W = GRID_SIZE * TILE_SIZE;
    const WORLD_H = GRID_SIZE * TILE_SIZE;

    function tileToWorldCenter(tileX, tileY) {
      return {
        x: tileX * TILE_SIZE + TILE_SIZE / 2,
        y: tileY * TILE_SIZE + TILE_SIZE / 2,
      };
    }

    function worldToTile(worldX, worldY) {
      return {
        tileX: Phaser.Math.Clamp(Math.floor(worldX / TILE_SIZE), 0, GRID_SIZE - 1),
        tileY: Phaser.Math.Clamp(Math.floor(worldY / TILE_SIZE), 0, GRID_SIZE - 1),
      };
    }

    function isIndestructibleWall(tileX, tileY) {
      const max = GRID_SIZE - 1;
      if (tileX === 0 || tileY === 0 || tileX === max || tileY === max) return true;
      if (tileX % 2 === 0 && tileY % 2 === 0) return true;
      return false;
    }

    function isSpawnSafe(tileX, tileY) {
      // Player spawn at (1,1) with two adjacent safe tiles.
      if (tileX === 1 && tileY === 1) return true;
      if (tileX === 1 && tileY === 2) return true;
      if (tileX === 2 && tileY === 1) return true;
      return false;
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
      }

      init(data) {
        this.mpState = null;
        this.localMp = data.localMp || false; // Shared keyboard mode
      }

      spawnEnemies() {
        // Disable enemies in multiplayer (PvP focus)
        if (this.localMp) return;

        // Spawn 2-4 enemies in safe corners (not overlapping player).
        const corners = [
          { x: GRID_SIZE - 2, y: 1 },
          { x: 1, y: GRID_SIZE - 2 },
          { x: GRID_SIZE - 2, y: GRID_SIZE - 2 },
          { x: 1, y: 1 },
        ];

        // Never spawn on player's exact tile.
        const filtered = corners.filter(c => !(c.x === this.playerTileX && c.y === this.playerTileY));
        Phaser.Utils.Array.Shuffle(filtered);

        const enemyCount = Phaser.Math.Between(2, 4);
        const spawnList = filtered.slice(0, enemyCount);

        for (const s of spawnList) {
          // If a destructible block is occupying the spawn, clear it.
          if (this.blockByTile.has(`${s.x},${s.y}`)) {
            this.destroyBlockAt(s.x, s.y);
          }

          const pos = tileToWorldCenter(s.x, s.y);
          const shadow = this.add.image(pos.x, pos.y + 14, 'shadow');
          shadow.setDepth(2.5);

          const sprite = this.add.sprite(pos.x, pos.y, 'enemy');
          sprite.setDepth(3);
          sprite.play('enemy-idle');

          this.enemies.push({
            sprite,
            shadow,
            tileX: s.x,
            tileY: s.y,
            isMoving: false,
            dir: Phaser.Math.RND.pick(['left', 'right', 'up', 'down']),
            dead: false,
            moveMs: 140,
          });
        }
      }

      updateEnemies() {
        for (const e of this.enemies) {
          if (!e || e.dead) continue;

          // Update shadow follow in case of tween drift.
          e.shadow.x = e.sprite.x;
          e.shadow.y = e.sprite.y + 14;

          // Contact damage (tile overlap)
          if (!this.isInvulnerable && e.tileX === this.playerTileX && e.tileY === this.playerTileY) {
            this.damagePlayer();
          }

          if (e.isMoving) continue;

          // Try to continue in same direction; if blocked, pick a new one.
          const attemptDirs = this.getEnemyAttemptDirs(e.dir);
          let moved = false;
          for (const dir of attemptDirs) {
            const d = this.dirToDelta(dir);
            const nx = e.tileX + d.dx;
            const ny = e.tileY + d.dy;
            if (this.isTileWalkableForEnemy(nx, ny)) {
              e.dir = dir;
              this.moveEnemyToTile(e, nx, ny);
              moved = true;
              break;
            }
          }

          if (!moved) {
            // stuck; randomize direction for next tick
            e.dir = Phaser.Math.RND.pick(['left', 'right', 'up', 'down']);
          }
        }
      }

      getEnemyAttemptDirs(primaryDir) {
        const dirs = ['left', 'right', 'up', 'down'];
        const rest = dirs.filter(d => d !== primaryDir);
        Phaser.Utils.Array.Shuffle(rest);
        return [primaryDir, ...rest];
      }

      dirToDelta(dir) {
        if (dir === 'left') return { dx: -1, dy: 0 };
        if (dir === 'right') return { dx: 1, dy: 0 };
        if (dir === 'up') return { dx: 0, dy: -1 };
        return { dx: 0, dy: 1 };
      }

      isTileWalkableForEnemy(tileX, tileY) {
        if (tileX < 0 || tileY < 0 || tileX >= GRID_SIZE || tileY >= GRID_SIZE) return false;
        if (isIndestructibleWall(tileX, tileY)) return false;
        if (this.blockByTile.has(`${tileX},${tileY}`)) return false;

        // Enemies treat any bomb as solid (even unarmed) to avoid camping it.
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tileX && b.tileY === tileY) return false;
        }

        // Avoid other enemies
        for (const other of this.enemies) {
          if (!other.dead && other.tileX === tileX && other.tileY === tileY) return false;
        }

        return true;
      }

      moveEnemyToTile(enemy, tileX, tileY) {
        enemy.isMoving = true;
        const to = tileToWorldCenter(tileX, tileY);

        this.tweens.add({
          targets: [enemy.sprite, enemy.shadow],
          x: to.x,
          y: (target) => (target === enemy.shadow ? to.y + 14 : to.y),
          duration: enemy.moveMs,
          ease: 'Linear',
          onComplete: () => {
            enemy.tileX = tileX;
            enemy.tileY = tileY;
            enemy.isMoving = false;

            // Check immediate contact after moving.
            if (!this.isInvulnerable && enemy.tileX === this.playerTileX && enemy.tileY === this.playerTileY) {
              this.damagePlayer();
            }
          }
        });
      }

      preload() {
        // Stage 1 uses generated textures (placeholders). No external assets required.
      }

      create() {
        this.createTextures();

        this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);

        // Stage 6 UI overlay
        if (!this.scene.isActive('UIScene')) {
          this.scene.launch('UIScene');
        }
        this.scene.bringToTop('UIScene');

        this.floorImages = [];
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const pos = tileToWorldCenter(x, y);
            const img = this.add.image(pos.x, pos.y, 'floor');
            img.setDepth(0);
            this.floorImages.push(img);
          }
        }

        this.walls = this.physics.add.staticGroup();
        this.blocks = this.physics.add.staticGroup();
        this.blockByTile = new Map();

        this.bombs = this.physics.add.staticGroup();
        this.activeBombs = [];

        this.explosions = this.add.group();
        this.blastRadius = 2;

        this.enemies = [];

        this.powerUps = [];
        this.powerUpByTile = new Map();

        const rng = this.mpState ? new SimpleRNG(this.mpState.seed) : Math;

        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const pos = tileToWorldCenter(x, y);

            if (isIndestructibleWall(x, y)) {
              const wall = this.walls.create(pos.x, pos.y, 'wall');
              wall.setDepth(2);
              continue;
            }

            if (!isSpawnSafe(x, y)) {
              // Destructible blocks on empty tiles (50% chance)
              // Use seeded RNG if multiplayer
              if (rng === Math ? Math.random() < 0.5 : rng.next() < 0.5) {
                const block = this.blocks.create(pos.x, pos.y, 'block');
                block.setDepth(2);
                this.blockByTile.set(`${x},${y}`,
                  { sprite: block, tileX: x, tileY: y }
                );
              }
            }
          }
        }

        // Multiplayer Setup
        this.mpState = null;

        // --- PLAYER 1 SETUP ---
        this.playerTileX = 1;
        this.playerTileY = 1;
        const spawn1 = tileToWorldCenter(1, 1);

        this.playerShadow = this.add.image(spawn1.x, spawn1.y + 14, 'shadow');
        this.playerShadow.setDepth(2.5);

        this.player = this.add.sprite(spawn1.x, spawn1.y, 'player');
        this.player.setDepth(3);
        this.player.setTint(0x8888ff); // Blue
        this.isMovingP1 = false;
        this.livesP1 = 3;
        this.maxBombsP1 = 1;
        this.blastRadiusP1 = 2; // Separate stats
        this.speedMsP1 = 120;

        // --- PLAYER 2 SETUP (Local MP) ---
        this.player2 = null;
        if (this.localMp) {
          const spawn2 = tileToWorldCenter(GRID_SIZE - 2, GRID_SIZE - 2);

          this.player2Shadow = this.add.image(spawn2.x, spawn2.y + 14, 'shadow');
          this.player2Shadow.setDepth(2.5);

          this.player2 = this.add.sprite(spawn2.x, spawn2.y, 'player');
          this.player2.setDepth(3);
          this.player2.setTint(0xff8888); // Red

          this.player2TileX = GRID_SIZE - 2;
          this.player2TileY = GRID_SIZE - 2;
          this.isMovingP2 = false;
          this.livesP2 = 3;
          this.maxBombsP2 = 1;
          this.blastRadiusP2 = 2;
          this.speedMsP2 = 120;
        }

        this.cursors = this.input.keyboard.createCursorKeys();
        this.keys = this.input.keyboard.addKeys('W,A,S,D');
        this.spaceKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
        this.enterKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.ENTER); // P2 Bomb

        // Ensure keys are captured
        this.input.keyboard.addCapture('SPACE,ENTER,W,A,S,D,UP,DOWN,LEFT,RIGHT');

        // Make sure the canvas can be focused
        const canvas = this.game.canvas;
        canvas.setAttribute('tabindex', '0');
        canvas.style.outline = 'none';
        this.input.on('pointerdown', () => canvas.focus());

        this.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);
        this.cameras.main.centerOn(WORLD_W / 2, WORLD_H / 2);

        this.score = 0;
        this.isInvulnerable = false;
        this.emitUiState();

        this.particles = this.add.particles(0, 0, 'particle');
        this.particles.setDepth(50);

        this.debrisParticles = this.add.particles(0, 0, 'debris-1');
        this.debrisParticles.setDepth(49);

        this.spawnEnemies();

        // Stage 7: Vignette Overlay
        this.vignette = this.add.image(WORLD_W / 2, WORLD_H / 2, 'vignette');
        this.vignette.setDepth(100);
        this.vignette.setScrollFactor(0);

        // Stage 7: Intro Zoom
        this.cameras.main.setZoom(1.2);
        this.tweens.add({
          targets: this.cameras.main,
          zoom: 1,
          duration: 800,
          ease: 'Cubic.easeOut'
        });
      }

      update() {
        // --- PLAYER 1 (WASD + Space) ---
        if (this.livesP1 > 0) {
          this.handlePlayerInput(this.player, 'p1', this.keys.W, this.keys.A, this.keys.S, this.keys.D, this.spaceKey);
          this.playerShadow.x = this.player.x;
          this.playerShadow.y = this.player.y + 14;
        } else {
          this.player.setVisible(false);
          this.playerShadow.setVisible(false);
        }

        // --- PLAYER 2 (Arrows + Enter) ---
        if (this.localMp && this.player2 && this.livesP2 > 0) {
          this.handlePlayerInput(this.player2, 'p2', this.cursors.up, this.cursors.left, this.cursors.down, this.cursors.right, this.enterKey);
          this.player2Shadow.x = this.player2.x;
          this.player2Shadow.y = this.player2.y + 14;
        } else if (this.player2) {
          this.player2.setVisible(false);
          this.player2Shadow.setVisible(false);
        }

        // Arm bombs
        for (const b of this.activeBombs) {
          if (!b.armed) {
            let safe = true;
            if (this.livesP1 > 0 && this.isOverlapping(this.player, b.sprite)) safe = false;
            if (this.localMp && this.livesP2 > 0 && this.isOverlapping(this.player2, b.sprite)) safe = false;

            if (safe) {
              b.armed = true;
              if (b.sprite.body) b.sprite.body.checkCollision.none = false;
            }
          }
        }

        this.updateEnemies();
      }

      isOverlapping(spriteA, spriteB) {
        if (!spriteA.visible || !spriteB.visible) return false;
        const d = Phaser.Math.Distance.Between(spriteA.x, spriteA.y, spriteB.x, spriteB.y);
        return d < TILE_SIZE * 0.45;
      }

      handlePlayerInput(sprite, pid, kUp, kLeft, kDown, kRight, kBomb) {
        const isMoving = (pid === 'p1') ? this.isMovingP1 : this.isMovingP2;

        if (!isMoving) {
          let dx = 0, dy = 0, dir = null;
          if (kLeft.isDown) { dx = -1; dy = 0; dir = 'left'; }
          else if (kRight.isDown) { dx = 1; dy = 0; dir = 'right'; }
          else if (kUp.isDown) { dx = 0; dy = -1; dir = 'up'; }
          else if (kDown.isDown) { dx = 0; dy = 1; dir = 'down'; }

          if (dx !== 0 || dy !== 0) {
            this.tryMoveByTile(pid, dx, dy, dir);
          } else {
            sprite.anims.stop();
            sprite.setFrame(this.getIdleFrameForDir(dir || 'down'));
          }
        }

        if (Phaser.Input.Keyboard.JustDown(kBomb)) {
          this.tryPlaceBomb(pid);
        }
      }

      tryMoveByTile(pid, dx, dy, dir) {
        const pTileX = (pid === 'p1') ? this.playerTileX : this.player2TileX;
        const pTileY = (pid === 'p1') ? this.playerTileY : this.player2TileY;
        const sprite = (pid === 'p1') ? this.player : this.player2;
        const shadow = (pid === 'p1') ? this.playerShadow : this.player2Shadow;
        const moveMs = (pid === 'p1') ? this.speedMsP1 : this.speedMsP2;

        const nx = pTileX + dx;
        const ny = pTileY + dy;

        if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) return;
        if (!this.isTileWalkable(nx, ny)) return;

        if (pid === 'p1') this.isMovingP1 = true;
        else this.isMovingP2 = true;

        const to = tileToWorldCenter(nx, ny);
        sprite.anims.play('walk-' + dir, true);

        this.tweens.add({
          targets: [sprite, shadow],
          x: to.x,
          y: (target) => (target === shadow ? to.y + 14 : to.y),
          duration: moveMs,
          ease: 'Linear',
          onComplete: () => {
            if (pid === 'p1') {
              this.playerTileX = nx;
              this.playerTileY = ny;
              this.isMovingP1 = false;
              this.tryCollectPowerUpAt(nx, ny, 'p1');
            } else {
              this.player2TileX = nx;
              this.player2TileY = ny;
              this.isMovingP2 = false;
              this.tryCollectPowerUpAt(nx, ny, 'p2');
            }
          }
        });
      }

      isTileWalkable(tileX, tileY) {
        if (isIndestructibleWall(tileX, tileY)) return false;
        if (this.blockByTile.has(`${tileX},${tileY}`)) return false;
        // Bombs are solid once armed
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tileX && b.tileY === tileY) {
            return b.armed === false;
          }
        }
        return true;
      }

      getIdleFrameForDir(dir) {
        const idxByDir = { down: 0, left: 4, right: 8, up: 12 };
        return idxByDir[dir] ?? 0;
      }

      tryPlaceBomb(pid) {
        const tx = (pid === 'p1') ? this.playerTileX : this.player2TileX;
        const ty = (pid === 'p1') ? this.playerTileY : this.player2TileY;
        const maxB = (pid === 'p1') ? this.maxBombsP1 : this.maxBombsP2;
        const blastR = (pid === 'p1') ? this.blastRadiusP1 : this.blastRadiusP2;

        if (isIndestructibleWall(tx, ty)) return;

        // Count ACTIVE bombs owned by this player
        const activeCount = this.activeBombs.filter(b => b && !b.exploded && b.owner === pid).length;
        if (activeCount >= maxB) return;

        // No stacking
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tx && b.tileY === ty) return;
        }

        const pos = tileToWorldCenter(tx, ty);
        if (this.blockByTile.has(`${tx},${ty}`)) return;

        const bombSprite = this.bombs.create(pos.x, pos.y, 'bomb');
        bombSprite.setDepth(2.8);
        bombSprite.body.checkCollision.none = true;

        const bomb = {
          sprite: bombSprite,
          tileX: tx,
          tileY: ty,
          armed: false,
          exploded: false,
          owner: pid,
          radius: blastR,
          glow: null
        };
        this.activeBombs.push(bomb);

        // Glow
        const glow = this.add.image(pos.x, pos.y + 2, 'soft-glow');
        glow.setDepth(2.7);
        glow.setTint(0xff6b4f);
        glow.setAlpha(0.6);
        glow.setScale(1.2);
        bomb.glow = glow;

        this.tweens.add({ targets: glow, alpha: 0.2, scale: 1.5, duration: 500, yoyo: true, repeat: -1 });
        this.tweens.add({ targets: bombSprite, scale: { from: 1, to: 1.08 }, duration: 220, yoyo: true, repeat: -1 });

        this.time.delayedCall(2400, () => this.explodeBomb(bomb));
      }

      explodeBomb(bomb) {
        if (!bomb || bomb.exploded) return;
        bomb.exploded = true;

        const bombSprite = bomb.sprite;
        if (bombSprite && bombSprite.active) {
          this.tweens.killTweensOf(bombSprite);
          bombSprite.destroy();
        }

        if (bomb.glow) {
          this.tweens.killTweensOf(bomb.glow);
          bomb.glow.destroy();
        }

        const tiles = this.getExplosionTiles(bomb.tileX, bomb.tileY, bomb.radius);

        this.cameras.main.shake(120, 0.006);

        for (const t of tiles) {
          const pos = tileToWorldCenter(t.tileX, t.tileY);

          const exp = this.add.image(pos.x, pos.y, 'explosion');
          exp.setBlendMode(Phaser.BlendModes.ADD);
          exp.setDepth(10);
          this.explosions.add(exp);

          this.tweens.add({
            targets: exp,
            alpha: { from: 0.95, to: 0 },
            scale: { from: 0.9, to: 1.35 },
            duration: 260,
            ease: 'Quad.easeOut',
            onComplete: () => exp.destroy(),
          });

          this.emitExplosionParticles(pos.x, pos.y);

          if (t.hitBlock) {
            this.destroyBlockAt(t.tileX, t.tileY);
          }
          this.killEnemiesAtTile(t.tileX, t.tileY);
        }

        this.checkPlayerDamage(tiles);
      }

      killEnemiesAtTile(tileX, tileY) {
        for (const e of this.enemies) {
          if (!e || e.dead) continue;
          if (e.tileX !== tileX || e.tileY !== tileY) continue;

          e.dead = true;
          e.isMoving = false;
          this.score += 100;
          this.emitUiState();
          this.emitEnemyDeathParticles(e.sprite.x, e.sprite.y);
          e.sprite.destroy();
          e.shadow.destroy();
        }
      }

      emitEnemyDeathParticles(x, y) {
        this.particles.emitParticleAt(x, y, {
          quantity: 16,
          lifespan: { min: 220, max: 520 },
          speed: { min: 40, max: 180 },
          scale: { start: 0.9, end: 0 },
          alpha: { start: 0.85, end: 0 },
          tint: [0x7ce6ff, 0xffd36b, 0xffffff],
          blendMode: 'ADD',
        });
      }

      getExplosionTiles(originX, originY, radius) {
        const out = [];
        out.push({ tileX: originX, tileY: originY, hitBlock: false });

        const dirs = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];

        for (const d of dirs) {
          for (let i = 1; i <= radius; i++) {
            const tx = originX + d.dx * i;
            const ty = originY + d.dy * i;
            if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) break;
            if (isIndestructibleWall(tx, ty)) break;

            const key = `${tx},${ty}`;
            if (this.blockByTile.has(key)) {
              out.push({ tileX: tx, tileY: ty, hitBlock: true });
              break;
            }
            out.push({ tileX: tx, tileY: ty, hitBlock: false });
          }
        }
        return out;
      }

      destroyBlockAt(tileX, tileY) {
        const key = `${tileX},${tileY}`;
        const block = this.blockByTile.get(key);
        if (!block) return;

        const s = block.sprite;
        this.blockByTile.delete(key);
        s.destroy();

        this.score += 10;
        this.emitUiState();

        const worldPos = tileToWorldCenter(tileX, tileY);
        this.emitBlockDebris(worldPos.x, worldPos.y);
        this.maybeSpawnPowerUp(tileX, tileY);
      }

      emitBlockDebris(x, y) {
        this.debrisParticles.emitParticleAt(x, y, {
          speed: { min: 50, max: 150 },
          lifespan: 600,
          gravityY: 200,
          quantity: 6,
          scale: { start: 0.8, end: 0.4 }
        });
      }

      maybeSpawnPowerUp(tileX, tileY) {
        if (this.powerUpByTile.has(`${tileX},${tileY}`)) return;
        if (Math.random() > 0.30) return;

        const r = Math.random();
        let type = 'bomb';
        if (r < 0.40) type = 'bomb';
        else if (r < 0.70) type = 'radius';
        else type = 'speed';

        const pos = tileToWorldCenter(tileX, tileY);
        const shadow = this.add.image(pos.x, pos.y + 14, 'shadow');
        shadow.setDepth(2.55);

        const key = type === 'bomb' ? 'powerup-bomb' : type === 'radius' ? 'powerup-radius' : 'powerup-speed';
        const sprite = this.add.image(pos.x, pos.y, key);
        sprite.setDepth(3.1);

        const powerUp = { type, tileX, tileY, sprite, shadow };
        this.powerUps.push(powerUp);
        this.powerUpByTile.set(`${tileX},${tileY}`, powerUp);

        this.tweens.add({ targets: sprite, y: pos.y + 3, duration: 800, yoyo: true, repeat: -1 });
      }

      tryCollectPowerUpAt(tileX, tileY, pid) {
        const key = `${tileX},${tileY}`;
        const p = this.powerUpByTile.get(key);
        if (!p) return;

        this.applyPowerUp(p.type, pid);
        this.powerUpByTile.delete(key);
        p.sprite.destroy();
        p.shadow.destroy();

        this.score += 25;
        this.emitUiState();
      }

      applyPowerUp(type, pid) {
        if (pid === 'p1') {
          if (type === 'bomb') this.maxBombsP1++;
          else if (type === 'radius') this.blastRadiusP1++;
          else if (type === 'speed') this.speedMsP1 = Math.max(65, this.speedMsP1 - 10);
        } else {
          if (type === 'bomb') this.maxBombsP2++;
          else if (type === 'radius') this.blastRadiusP2++;
          else if (type === 'speed') this.speedMsP2 = Math.max(65, this.speedMsP2 - 10);
        }
        this.emitUiState();
      }

      checkPlayerDamage(explosionTiles) {
        if (this.livesP1 > 0 && !this.isInvulnerable) {
          for (const t of explosionTiles) {
            if (t.tileX === this.playerTileX && t.tileY === this.playerTileY) {
              this.damagePlayer('p1');
              break;
            }
          }
        }
        if (this.localMp && this.player2 && this.livesP2 > 0) {
          for (const t of explosionTiles) {
            if (t.tileX === this.player2TileX && t.tileY === this.player2TileY) {
              this.damagePlayer('p2');
              break;
            }
          }
        }
      }

      damagePlayer(pid) {
        if (pid === 'p1') {
          this.livesP1--;
          if (this.livesP1 <= 0) {
            this.player.setVisible(false);
            this.playerShadow.setVisible(false);
            this.emitBlockDebris(this.player.x, this.player.y);
          } else {
            const spawn = tileToWorldCenter(1, 1);
            this.playerTileX = 1; this.playerTileY = 1;
            this.player.setPosition(spawn.x, spawn.y);
          }
        } else {
          this.livesP2--;
          if (this.livesP2 <= 0) {
            this.player2.setVisible(false);
            this.player2Shadow.setVisible(false);
            this.emitBlockDebris(this.player2.x, this.player2.y);
          } else {
            const spawn = tileToWorldCenter(GRID_SIZE - 2, GRID_SIZE - 2);
            this.player2TileX = GRID_SIZE - 2; this.player2TileY = GRID_SIZE - 2;
            this.player2.setPosition(spawn.x, spawn.y);
          }
        }
        this.emitUiState();
        this.cameras.main.shake(180, 0.012);
      }

      emitUiState() {
        if (!this.game || !this.game.events) return;
        this.game.events.emit('ui:update', {
          lives: this.livesP1,
          livesP2: this.localMp ? this.livesP2 : null,
          localMp: this.localMp,
        });
      }

      emitExplosionParticles(x, y) {
        this.particles.emitParticleAt(x, y, {
          quantity: 14,
          lifespan: { min: 180, max: 420 },
          speed: { min: 40, max: 170 },
          scale: { start: 0.8, end: 0 },
          blendMode: 'ADD',
        });
      }

      setupMpEvents() {
        const socket = this.mpState.socket;

        socket.on('player:join', (data) => {
          this.createOtherPlayer(data.slot);
        });

        socket.on('player:leave', (data) => {
          if (this.otherPlayers[data.slot]) {
            this.otherPlayers[data.slot].destroy();
            delete this.otherPlayers[data.slot];
          }
        });

        socket.on('player:moved', (data) => {
          this.updateOtherPlayer(data.slot, data.x, data.y, data.anim, data.dir);
        });

        socket.on('game:placeBomb', (data) => {
          // If it's me, I already placed it. Only spawn for others.
          if (data.slot !== this.mpState.slot) {
            this.spawnRemoteBomb(data.tileX, data.tileY);
          }
        });
      }

      createOtherPlayer(slot) {
        if (this.otherPlayers[slot]) return;

        // Spawn remote player at default location or wait for updates
        // For simplicity, spawn at their home corner
        let tx = 1, ty = 1;
        if (slot === 'p2') { tx = GRID_SIZE - 2; ty = GRID_SIZE - 2; }

        const pos = tileToWorldCenter(tx, ty);
        const sprite = this.add.sprite(pos.x, pos.y, 'player');
        sprite.setDepth(3);
        if (slot === 'p2') sprite.setTint(0xff8888);
        else sprite.setTint(0x8888ff);

        this.otherPlayers[slot] = sprite;
      }

      updateOtherPlayer(slot, worldX, worldY, animKey, dir) {
        const p = this.otherPlayers[slot];
        if (!p) return;

        // Simple tween to new position
        this.tweens.add({
          targets: p,
          x: worldX,
          y: worldY,
          duration: this.tileMoveMs,
          ease: 'Linear'
        });

        if (animKey) {
          p.play(animKey, true);
        } else {
          p.anims.stop();
          p.setFrame(this.getIdleFrameForDir(dir || 'down'));
        }
      }

      spawnRemoteBomb(tileX, tileY) {
        // Force spawn a bomb at location, bypassing ownership checks/counts for local player
        const pos = tileToWorldCenter(tileX, tileY);
        const bombSprite = this.bombs.create(pos.x, pos.y, 'bomb');
        bombSprite.setDepth(2.8);
        bombSprite.body.checkCollision.none = true;

        const bomb = {
          sprite: bombSprite,
          tileX: tileX,
          tileY: tileY,
          armed: false,
          exploded: false,
          glow: null
        };
        this.activeBombs.push(bomb);

        // Add glow
        const glow = this.add.image(pos.x, pos.y + 2, 'soft-glow');
        glow.setDepth(2.7);
        glow.setTint(0xff6b4f);
        glow.setAlpha(0.6);
        glow.setScale(1.2);
        bomb.glow = glow;

        this.tweens.add({ targets: glow, alpha: 0.2, scale: 1.5, duration: 500, yoyo: true, repeat: -1 });
        this.tweens.add({ targets: bombSprite, scale: { from: 1, to: 1.08 }, duration: 220, yoyo: true, repeat: -1 });

        this.time.delayedCall(2400, () => this.explodeBomb(bomb));
      }

      createTextures() {
        if (!this.textures.exists('floor')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x162033, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 6);
          g.fillStyle(0x1f2d47, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 8, 6);
          g.fillStyle(0x0b0f1a, 0.25);
          g.fillRect(0, TILE_SIZE - 6, TILE_SIZE, 6);
          g.generateTexture('floor', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('wall')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x3e4f73, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0x556a93, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 10, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0x6f86b0, 0.55);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('wall', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('block')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x8a5a3c, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0xb3784f, 1);
          g.fillRoundedRect(5, 5, TILE_SIZE - 10, TILE_SIZE - 12, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0xe2b37c, 0.35);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('block', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('player')) {
          // Player placeholder
          const size = TILE_SIZE;
          const sheetKey = 'player-sheet';
          if (!this.textures.exists(sheetKey)) {
            // ...
          }
          // inline generation
          const tex = this.textures.createCanvas(sheetKey, size * 4, size * 4);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size * 4);

          const dirColors = {
            down: { main: '#3ee6a8', edge: 'rgba(182,255,231,0.75)' },
            left: { main: '#4fd0ff', edge: 'rgba(190,240,255,0.75)' },
            right: { main: '#ffb84f', edge: 'rgba(255,236,190,0.75)' },
            up: { main: '#d36bff', edge: 'rgba(245,210,255,0.75)' },
          };

          const roundRect = (context, x, y, w, h, r) => {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          };

          const drawFrame = (frameX, frameY, main, edge, step) => {
            const ox = frameX * size;
            const oy = frameY * size;
            ctx.clearRect(ox, oy, size, size);
            const cx = ox + size / 2;
            const cy = oy + size / 2 - 2;
            const wobble = (step === 1 ? -2 : step === 3 ? 2 : 0);
            const bob = (step === 2 ? 1 : 0);
            ctx.fillStyle = main;
            roundRect(ctx, cx - 14 + wobble, cy - 16 + bob, 28, 28, 10);
            ctx.fill();
            ctx.strokeStyle = edge;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8 + wobble, cy - 6 + bob, 16, 6);
          };

          Object.keys(dirColors).forEach((dir, row) => {
            // dirs: down, left, right, up
            // but object keys order is not guaranteed? 
            // safest to iterate array
          });

          ['down', 'left', 'right', 'up'].forEach((dir, row) => {
            const c = dirColors[dir];
            for (let col = 0; col < 4; col++) {
              drawFrame(col, row, c.main, c.edge, col);
            }
          });

          tex.refresh();
          this.textures.addSpriteSheet('player', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);
        }

        // ANIMS check
        if (!this.anims.exists('walk-down')) {
          this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }), frameRate: 10, repeat: -1 });
        }


        if (!this.textures.exists('enemy')) {
          const size = TILE_SIZE;
          const sheetKey = 'enemy-sheet';
          const tex = this.textures.createCanvas(sheetKey, size * 4, size);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size);

          const roundRect = (context, x, y, w, h, r) => {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          };

          for (let i = 0; i < 4; i++) {
            const ox = i * size;
            const cx = ox + size / 2;
            const cy = size / 2 - 2;
            const bob = (i === 1 ? 1 : i === 3 ? -1 : 0);
            const glow = (i === 2 ? 0.85 : 0.65);
            ctx.clearRect(ox, 0, size, size);
            ctx.fillStyle = `rgba(0,0,0,0.22)`;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 28, 14, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff4f7e';
            roundRect(ctx, cx - 14, cy - 16 + bob, 28, 28, 10);
            ctx.fill();
            ctx.strokeStyle = `rgba(255,230,240,${glow})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8, cy - 6 + bob, 16, 6);
          }
          tex.refresh();
          this.textures.addSpriteSheet('enemy', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);
        }

        if (!this.anims.exists('enemy-idle')) {
          this.anims.create({
            key: 'enemy-idle',
            frames: this.anims.generateFrameNumbers('enemy', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1,
          });
        }

        if (!this.textures.exists('shadow')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x000000, 0.25);
          g.fillEllipse(TILE_SIZE / 2, TILE_SIZE / 2, 30, 16);
          g.generateTexture('shadow', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('bomb')) {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x0b0f1a, 0.22);
          g.fillEllipse(size / 2, size / 2 + 14, 30, 16);
          g.fillStyle(0x2b2f3a, 1);
          g.fillCircle(size / 2, size / 2 + 2, 14);
          g.fillStyle(0x495062, 1);
          g.fillCircle(size / 2 - 3, size / 2 - 1, 10);
          g.lineStyle(2, 0xcfd6e6, 0.35);
          g.strokeCircle(size / 2, size / 2 + 2, 14);
          g.lineStyle(3, 0xffc04d, 1);
          g.beginPath();
          g.moveTo(size / 2 + 8, size / 2 - 10);
          g.lineTo(size / 2 + 16, size / 2 - 16);
          g.strokePath();
          g.fillStyle(0xff6b4f, 1);
          g.fillCircle(size / 2 + 16, size / 2 - 16, 3);
          g.generateTexture('bomb', size, size);
          g.destroy();
        }

        if (!this.textures.exists('explosion')) {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffd36b, 0.9);
          g.fillCircle(size / 2, size / 2, 10);
          g.fillStyle(0xff6b4f, 0.75);
          g.fillCircle(size / 2, size / 2, 16);
          g.fillStyle(0xffffff, 0.65);
          g.fillCircle(size / 2, size / 2, 6);
          g.generateTexture('explosion', size, size);
          g.destroy();
        }

        if (!this.textures.exists('particle')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffffff, 1);
          g.fillCircle(4, 4, 4);
          g.generateTexture('particle', 8, 8);
          g.destroy();
        }

        if (!this.textures.exists('powerup-bomb')) {
          const size = TILE_SIZE;
          const makeIcon = (key, base, accent, glyph) => {
            const g = this.make.graphics({ x: 0, y: 0, add: false });
            g.fillStyle(0x000000, 0.22);
            g.fillEllipse(size / 2, size / 2 + 14, 26, 14);
            g.fillStyle(base, 1);
            g.fillRoundedRect(size / 2 - 14, size / 2 - 16, 28, 28, 10);
            g.lineStyle(2, accent, 0.8);
            g.strokeRoundedRect(size / 2 - 14, size / 2 - 16, 28, 28, 10);
            g.fillStyle(accent, 1);
            if (glyph === 'B') {
              g.fillCircle(size / 2, size / 2 - 2, 7);
              g.lineStyle(3, accent, 1);
              g.beginPath();
              g.moveTo(size / 2 + 6, size / 2 - 10);
              g.lineTo(size / 2 + 12, size / 2 - 14);
              g.strokePath();
            } else if (glyph === 'R') {
              g.fillCircle(size / 2, size / 2 - 2, 9);
              g.lineStyle(2, 0xffffff, 0.8);
              g.strokeCircle(size / 2, size / 2 - 2, 12);
            } else if (glyph === 'S') {
              g.lineStyle(4, accent, 1);
              g.beginPath();
              g.moveTo(size / 2 - 6, size / 2 + 6);
              g.lineTo(size / 2 + 8, size / 2 - 8);
              g.strokePath();
              g.fillStyle(0xffffff, 0.9);
              g.fillCircle(size / 2 + 8, size / 2 - 8, 3);
            }
            g.generateTexture(key, size, size);
            g.destroy();
          };
          makeIcon('powerup-bomb', 0x1f2d47, 0xffd36b, 'B');
          makeIcon('powerup-radius', 0x223a2a, 0x7ce6ff, 'R');
          makeIcon('powerup-speed', 0x2e1f47, 0xff6b4f, 'S');
        }

        if (!this.textures.exists('debris-1')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xb3784f, 1);
          g.beginPath();
          g.moveTo(0, 0);
          g.lineTo(6, 2);
          g.lineTo(4, 7);
          g.lineTo(0, 5);
          g.closePath();
          g.fill();
          g.generateTexture('debris-1', 8, 8);
          g.clear();
          g.fillStyle(0x8a5a3c, 1);
          g.fillRect(0, 0, 5, 5);
          g.generateTexture('debris-2', 6, 6);
          g.destroy();
        }

        if (!this.textures.exists('soft-glow')) {
          const size = 64;
          const canvas = this.textures.createCanvas('soft-glow', size, size);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
          grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, size, size);
          canvas.refresh();
        }

        if (!this.textures.exists('vignette')) {
          const w = WORLD_W;
          const h = WORLD_H;
          const canvas = this.textures.createCanvas('vignette', w, h);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.35, w / 2, h / 2, w * 0.85);
          grad.addColorStop(0, 'rgba(0,0,0,0)');
          grad.addColorStop(1, 'rgba(0,2,10,0.6)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);
          canvas.refresh();
        }
      }
    }

    class UIScene extends Phaser.Scene {
      constructor() {
        super({ key: 'UIScene' });
      }

      create() {
        this.score = 0;
        this.lives = 3;
        this.maxBombs = 1;
        this.blastRadius = 2;
        this.speed = 0;

        this.panel = this.add.rectangle(10, 10, 520, 52, 0x0b0f1a, 0.72).setOrigin(0, 0);
        this.panel.setStrokeStyle(1, 0xeaf2ff, 0.12);

        this.scoreText = this.add.text(18, 16, 'Score: 0', { fontSize: '14px', color: '#eaf2ff', fontStyle: '800' });
        this.livesText = this.add.text(18, 36, 'Lives: 3', { fontSize: '12px', color: '#cfe0ff', fontStyle: '600' });

        // Ability icons + values
        this.iconBomb = this.add.image(120, 38, 'powerup-bomb').setScale(0.45).setAlpha(0.95);
        this.iconRadius = this.add.image(210, 38, 'powerup-radius').setScale(0.45).setAlpha(0.95);
        this.iconSpeed = this.add.image(310, 38, 'powerup-speed').setScale(0.45).setAlpha(0.95);
        this.statsText = this.add.text(140, 36, '1     2     0', { fontSize: '12px', color: '#cfe0ff', fontStyle: '800' });

        // Restart button directly under the panel so it is always visible.
        this.restartBtnBg = this.add.rectangle(10, 66, 110, 32, 0xffd36b, 1).setOrigin(0, 0);
        this.restartBtnBg.setStrokeStyle(1, 0xffffff, 0.28);
        this.restartBtnText = this.add.text(10 + 55, 66 + 7, 'Restart', { fontSize: '12px', color: '#0b0f1a', fontStyle: '900' }).setOrigin(0.5, 0);

        // Restart button directly under the panel so it is always visible.
        this.restartBtnBg = this.add.rectangle(10, 66, 110, 32, 0xffd36b, 1).setOrigin(0, 0);
        this.restartBtnBg.setStrokeStyle(1, 0xffffff, 0.28);
        this.restartBtnText = this.add.text(10 + 55, 66 + 7, 'Restart', { fontSize: '12px', color: '#0b0f1a', fontStyle: '900' }).setOrigin(0.5, 0);

        this.restartBtnBg.setInteractive({ useHandCursor: true });
        this.restartBtnBg.on('pointerdown', () => this.restartGame());

        // Multiplayer Button
        this.mpBtnBg = this.add.rectangle(130, 66, 110, 32, 0x7cdaff, 1).setOrigin(0, 0);
        this.mpBtnBg.setStrokeStyle(1, 0xffffff, 0.28);
        this.mpBtnText = this.add.text(130 + 55, 66 + 7, 'PvP Mode', { fontSize: '12px', color: '#0b0f1a', fontStyle: '900' }).setOrigin(0.5, 0);
        this.mpBtnBg.setInteractive({ useHandCursor: true });
        this.mpBtnBg.on('pointerdown', () => this.startMultiplayer());

        // Help Button (?)
        this.helpBtnBg = this.add.rectangle(250, 66, 32, 32, 0x2e1f47, 1).setOrigin(0, 0);
        this.helpBtnBg.setStrokeStyle(1, 0xffffff, 0.28);
        this.helpBtnText = this.add.text(250 + 16, 66 + 7, '?', { fontSize: '14px', color: '#ffffff', fontStyle: '900' }).setOrigin(0.5, 0);
        this.helpBtnBg.setInteractive({ useHandCursor: true });
        this.helpBtnBg.on('pointerdown', () => this.toggleHelp());

        // Controls Text (Always visible small hint)
        this.add.text(10, 110, '[WASD] Move   [SPACE] Bomb', { fontSize: '11px', color: '#ffffff', alpha: 0.5 });

        // --- HELP MODAL GROUP ---
        this.helpGroup = this.add.group();

        // overlay
        const ov = this.add.rectangle(WORLD_W / 2, WORLD_H / 2, WORLD_W, WORLD_H, 0x000000, 0.85);
        ov.setInteractive(); // block clicks
        this.helpGroup.add(ov);

        // panel
        const pW = 400, pH = 380;
        const panel = this.add.rectangle(WORLD_W / 2, WORLD_H / 2, pW, pH, 0x141a2a, 1);
        panel.setStrokeStyle(2, 0x3e4f73);
        this.helpGroup.add(panel);

        const cx = WORLD_W / 2;
        const cy = WORLD_H / 2 - pH / 2 + 20;

        const styleH = { fontSize: '18px', color: '#ffd36b', fontStyle: 'bold' };
        const styleB = { fontSize: '13px', color: '#eaf2ff', align: 'center', wordWrap: { width: pW - 40 } };
        const styleS = { fontSize: '11px', color: '#8d9ebf' };

        this.helpGroup.add(this.add.text(cx, cy - 10, 'HOW TO PLAY', styleH).setOrigin(0.5));

        // Single Player Section
        this.helpGroup.add(this.add.text(cx, cy + 20, 'SINGLE PLAYER', styleS).setOrigin(0.5));
        this.helpGroup.add(this.add.text(cx, cy + 35, 'Move: WASD or Arrows\nBomb: SPACE', styleB).setOrigin(0.5, 0));

        // PvP Section
        this.helpGroup.add(this.add.text(cx, cy + 85, 'LOCAL PvP (2 PLAYER)', styleS).setOrigin(0.5));
        this.helpGroup.add(this.add.text(cx, cy + 100, 'P1 (Blue): WASD + SPACE\nP2 (Red): ARROWS + ENTER', styleB).setOrigin(0.5, 0));

        this.helpGroup.add(this.add.text(cx, cy + 155, 'POWER-UPS', styleS).setOrigin(0.5));

        // manual icons
        this.helpGroup.add(this.add.image(cx - 100, cy + 185, 'powerup-bomb').setScale(0.7));
        this.helpGroup.add(this.add.text(cx - 70, cy + 177, '+1 Max Bomb', { fontSize: '12px', color: '#ffd36b' }));

        this.helpGroup.add(this.add.image(cx + 20, cy + 185, 'powerup-radius').setScale(0.7));
        this.helpGroup.add(this.add.text(cx + 50, cy + 177, '+ Blast Radius', { fontSize: '12px', color: '#7ce6ff' }));

        this.helpGroup.add(this.add.image(cx - 100, cy + 225, 'powerup-speed').setScale(0.7));
        this.helpGroup.add(this.add.text(cx - 70, cy + 217, '+ Move Speed', { fontSize: '12px', color: '#ff6b4f' }));

        this.helpGroup.add(this.add.text(cx, cy + 270, 'Click anywhere to close', { fontSize: '12px', color: '#ffffff', alpha: 0.5 }).setOrigin(0.5));

        // Close logic
        ov.on('pointerdown', () => this.toggleHelp());

        this.helpGroup.setVisible(false);
        this.isHelpOpen = false;

        // Keep UI fixed to camera.
        this.cameras.main.setScroll(0, 0);

        this._uiHandler = (payload) => this.applyUi(payload);
        this.game.events.on('ui:update', this._uiHandler);

        this.events.once(Phaser.Scenes.Events.SHUTDOWN, () => {
          if (this._uiHandler) this.game.events.off('ui:update', this._uiHandler);
        });

        // Pull initial state if GameScene already exists.
        const gs = this.scene.get('GameScene');
        if (gs && gs.emitUiState) gs.emitUiState();
      }

      applyUi(payload) {
        if (payload.localMp) {
          this.livesText.setText(`P1: ${payload.lives}   P2: ${payload.livesP2}`);
          this.statsText.setVisible(false);
          return;
        } else {
          this.statsText.setVisible(true);
        }
        const prevScore = this.score;
        const prevLives = this.lives;

        this.score = payload.score ?? this.score;
        this.lives = payload.lives ?? this.lives;
        this.maxBombs = payload.maxBombs ?? this.maxBombs;
        this.blastRadius = payload.blastRadius ?? this.blastRadius;
        this.speed = payload.speed ?? this.speed;

        this.scoreText.setText(`Score: ${this.score}`);
        this.livesText.setText(`Lives: ${this.lives}`);
        this.statsText.setText(`${this.maxBombs}     ${this.blastRadius}     ${this.speed}`);

        if (this.score !== prevScore) {
          this.tweens.add({ targets: this.scoreText, scaleX: 1.15, scaleY: 1.15, duration: 90, yoyo: true });
        }
        if (this.lives !== prevLives) {
          this.tweens.add({ targets: [this.livesText, this.panel], alpha: { from: 1, to: 0.6 }, duration: 90, yoyo: true, repeat: 2 });
        }
      }

      restartGame() {
        // Restart gameplay and reset UI values.
        this.score = 0;
        this.lives = 3;
        this.maxBombs = 1;
        this.blastRadius = 2;
        this.speed = 0;
        this.applyUi({ score: 0, lives: 3, maxBombs: 1, blastRadius: 2, speed: 0 });

        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { mpState: null, localMp: false });
        this.scene.bringToTop('UIScene');
      }

      startMultiplayer() {
        // Local Shared Keyboard Mode
        this.scene.start('GameScene', { localMp: true });
        this.mpBtnText.setText('PvP (Local)');
        return;

        if (typeof io === 'undefined') {
          alert('Socket.IO not loaded. Is the server running?');
          return;
        }

        // If opening via file://, force connection to localhost:3000
        const url = (location.protocol === 'file:') ? 'http://localhost:3000' : undefined;
        const socket = io(url);

        socket.on('connect', () => {
          console.log('Connected to server!');
          this.mpBtnText.setText('Waiting...');
        });

        socket.on('game:init', (data) => {
          // data = { slot: 'p1', mapSeed: 12345, players: [] }
          if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');

          this.score = 0;
          this.lives = 3;
          this.applyUi({ score: 0, lives: 3 });

          this.scene.start('GameScene', {
            mpState: {
              socket: socket,
              slot: data.slot,
              seed: data.mapSeed,
              players: data.players
            }
          });
          this.mpBtnText.setText(`Playing as ${data.slot.toUpperCase()}`);
        });

        socket.on('server:full', () => {
          alert('Server is full (2 players max)');
          socket.disconnect();
        });
      }

      toggleHelp() {
        this.isHelpOpen = !this.isHelpOpen;
        this.helpGroup.setVisible(this.isHelpOpen);
        if (this.isHelpOpen) {
          this.scene.bringToTop('UIScene'); // ensure modal covers game
        }
      }
    }

    function getGameParentSize() {
      const el = document.getElementById('game-container');
      const rect = el.getBoundingClientRect();
      return { width: Math.max(1, Math.floor(rect.width)), height: Math.max(1, Math.floor(rect.height)) };
    }

    const initialSize = getGameParentSize();

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      backgroundColor: '#000000',
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false,
        },
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH,
        width: WORLD_W,
        height: WORLD_H,
      },
      scene: [GameScene, UIScene],
    };

    const game = new Phaser.Game(config);

    // Prevent page scrolling when SPACE is pressed (some browsers still scroll even if Phaser captures).
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') e.preventDefault();
    }, { passive: false });

    // Document-level SPACE fallback (helps when embedded previews/IDEs swallow key events).
    document.addEventListener('keydown', (e) => {
      const isSpace = (e.code === 'Space') || (e.key === ' ') || (e.key === 'Spacebar');
      if (!isSpace) return;
      e.preventDefault();
      if (typeof window.__bmPlaceBomb === 'function') window.__bmPlaceBomb();
    }, { passive: false });

    function handleResize() {
      // Phaser FIT will re-fit into the parent automatically, but it needs a scale refresh.
      if (!game || !game.scale) return;
      game.scale.refresh();
    }

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);
  </script>
</body>

</html>