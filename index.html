<!doctype html>
<html lang="en">
<!--
  DISCLAIMER: This is a non-profit fan project created for educational purposes.
  It is not affiliated with, endorsed, sponsored, or specifically approved by Konami Digital Entertainment.
  "Bomberman" is a registered trademark of Konami Digital Entertainment.
-->

<head>
  <meta charset="utf-8" />
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-N6EHHXGZNC"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-N6EHHXGZNC');
  </script>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="google-site-verification" content="sROYzqvwKAGizls3N4z0MBn3WqruZm5MEYGEeDxCzNc" />
  <title>Bomb Battle Web | Play Free Local PvP & Unfair Mode</title>
  <link rel="icon" type="image/png" href="favicon.ico">

  <!-- SEO Meta Tags -->
  <meta name="description"
    content="Play the ultimate Bomb Battle web game! Features Local Multiplayer PvP, a brutal Unfair Mode, Ghost Enemies, and Epic Boss Battles. Free to play in your browser." />
  <meta name="keywords"
    content="bomb battle, arcade, free game, browser game, phaser 3, multiplayer, pvp, html5 game, bomber clone" />
  <meta name="robots" content="index, follow" />

  <!-- Open Graph / Social Sharing -->
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Bomb Battle Web - Unfair Mode & Boss Battles" />
  <meta property="og:description"
    content="Blow up your friends in Local PvP or challenge the Iron Bull Boss! The best free BomberMan clone on the web." />
  <meta property="og:image" content="https://sauraodalvi.github.io/BomberMan/og-image.png" />
  <meta property="og:url" content="https://sauraodalvi.github.io/BomberMan/" />

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="BomberMan Web | Free Arcade Action" />
  <meta name="twitter:description" content="Can you beat Unfair Mode? Play now." />

  <!-- Structured Data (JSON-LD) for Rich Results -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "VideoGame",
    "name": "Bomb Battle Web",
    "description": "The ultimate free browser-based Bomb Battle game. Features 2-Player Local PvP, Unfair Mode, and Boss Battles.",
    "genre": ["Arcade", "Action", "Multiplayer"],
    "playMode": "MultiPlayer",
    "applicationCategory": "Browser Game",
    "operatingSystem": "Any",
    "author": {
      "@type": "Person",
      "name": "Saurav Dalvi"
    },
    "image": "https://sauraodalvi.github.io/BomberMan/og-image.png",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD",
      "availability": "https://schema.org/InStock"
    }
  }
  </script>
  <style>
    :root {
      --ad-width: 200px;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: #0b0f1a;
      overflow: hidden;
    }

    #app {
      height: 100%;
      height: 100dvh;
      width: 100%;
      display: flex;
      flex-direction: row;
    }

    .ad-slot {
      width: var(--ad-width);
      min-width: var(--ad-width);
      max-width: var(--ad-width);
      flex: 0 0 var(--ad-width);
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.8);
      background: linear-gradient(180deg, #141a2a, #0d1220);
      border-left: 1px solid rgba(255, 255, 255, 0.08);
      border-right: 1px solid rgba(0, 0, 0, 0.35);
      box-sizing: border-box;
      user-select: none;
    }

    #center-panel {
      flex: 1;
      min-width: 1px;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: radial-gradient(1200px 800px at 50% 40%, rgba(88, 156, 255, 0.18), rgba(7, 10, 18, 0.95));
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: none;
      /* Firefox */
      -ms-overflow-style: none;
      /* IE/Edge */
    }

    #center-panel::-webkit-scrollbar {
      display: none;
      /* Chrome/Safari */
    }

    #game-container {
      width: 100%;
      /* Default Desktop: Game takes focus, text below */
      height: calc(100vh - 40px);
      min-height: 500px;
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 0;
    }

    /* Ensure canvas stays crisp and centered */
    canvas {
      display: block;
      image-rendering: auto;
      max-width: 100%;
      max-height: 100%;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    }

    #seo-content {
      width: 100%;
      max-width: 900px;
      padding: 40px 20px;
      color: #eaf2ff;
      line-height: 1.6;
      font-size: 1.1rem;
    }

    #seo-content h1,
    #seo-content h2,
    #seo-content h3 {
      color: #ffd36b;
      margin-top: 2rem;
    }

    #seo-content p {
      margin-bottom: 1.5rem;
      color: #b0c2e3;
    }

    #seo-content .keyword-highlight {
      color: #fff;
      font-weight: bold;
    }

    @media (max-width: 520px) {
      :root {
        --ad-width: 0px;
        /* Hide ads logic */
      }
    }

    /* Mobile Controls */
    #mobile-controls {
      display: none;
      width: 100%;
      height: 180px;
      background: #0b0f1a;
      border-top: 1px solid #3e4f73;
      padding: 10px 30px;
      box-sizing: border-box;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      z-index: 50;
    }

    #dpad {
      display: grid;
      grid-template: " .  u  . "
        " l  .  r "
        " .  d  . ";
      gap: 8px;
    }

    .d-btn {
      width: 48px;
      height: 48px;
      background: #2a354c;
      border: 2px solid #556a93;
      border-radius: 8px;
      color: #fff;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
      cursor: pointer;
    }

    .d-btn:active,
    .d-btn.active {
      background: #4f6491;
      border-color: #7ce6ff;
    }

    #btn-u {
      grid-area: u;
    }

    #btn-d {
      grid-area: d;
    }

    #btn-l {
      grid-area: l;
    }

    #btn-r {
      grid-area: r;
    }

    #m-bomb {
      width: 80px;
      height: 80px;
      background: #3a1000;
      border: 2px solid #ff6b4f;
      border-radius: 50%;
      color: #fff;
      font-size: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    }

    #m-bomb:active,
    #m-bomb.active {
      background: #5a2000;
      transform: scale(0.95);
    }

    #m-detonate {
      width: 56px;
      height: 56px;
      background: #2a0a3a;
      border: 2px solid #d67cff;
      border-radius: 50%;
      color: #fff;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      touch-action: manipulation;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    }

    #m-detonate:active,
    #m-detonate.active {
      background: #4a1a6a;
      transform: scale(0.95);
    }

    /* Swap Button */
    #swap-btn {
      width: 32px;
      height: 32px;
      background: #1f2d47;
      border: 1px solid #3e4f73;
      border-radius: 4px;
      color: #8d9ebf;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      cursor: pointer;
    }

    #mobile-controls.flipped {
      flex-direction: row-reverse;
    }

    @media (max-width: 850px) {
      .ad-slot {
        display: none;
      }

      #app {
        flex-direction: column;
      }

      #center-panel {
        flex-direction: column;
        width: 100%;
      }

      #game-container {
        /* Mobile: Reserve space for controls (170px) */
        height: calc(100dvh - 170px);
        min-height: 0;
      }

      #mobile-controls {
        display: flex;
        height: 170px;
        flex-shrink: 0;
        margin-bottom: 0;
        padding: 5px 20px;
        align-items: center;
      }

      canvas {
        max-height: 100%;
        max-width: 100%;
        width: auto !important;
        height: auto !important;
        aspect-ratio: 1/1;
      }
    }
  </style>
</head>

<body>
  <div id="app">
    <div id="ad-left" class="ad-slot">Left Ad (200px)</div>
    <div id="center-panel">
      <div id="game-container"></div>

      <div id="mobile-controls">
        <div id="dpad">
          <div id="btn-u" class="d-btn" data-key="up">‚ñ≤</div>
          <div id="btn-l" class="d-btn" data-key="left">‚óÄ</div>
          <div id="btn-r" class="d-btn" data-key="right">‚ñ∂</div>
          <div id="btn-d" class="d-btn" data-key="down">‚ñº</div>
        </div>
        <div id="swap-btn" title="Swap Controls">‚áÑ</div>
        <div style="display:flex; gap:12px; align-items:center;">
          <div id="m-detonate" data-key="detonate" role="button" style="display:none;">üì°</div>
          <div id="m-bomb" data-key="bomb" role="button">üí£</div>
        </div>
      </div>

      <!-- SEO Content Section -->
      <article id="seo-content" itemscope itemtype="https://schema.org/VideoGame">
        <h1 itemprop="name">Bomb Battle: The Ultimate Unfair Bomber Clone for Browser</h1>
        <p class="intro">
          Looking for a <strong>no login web game</strong> that throws you straight into the action?
          <strong>Bomb Battle Web</strong> is a fast-paced, <span class="keyword-highlight">browser-based game</span>
          inspired by the classic
          arcade strategy of <em>Bomberman</em>, but with a wicked twist. Whether you want to challenge a friend in
          <span class="keyword-highlight">multiplayer bomberman</span> PvP or test your sanity in the brutal
          <a href="#unfair-mode" style="color:#ff4f4f">Unfair Mode</a>, this game delivers instant chaos without
          downloads or sign-ups.
        </p>

        <section id="what-is-it">
          <h2>üí£ What is Unfair Bomb Battle?</h2>
          <p>
            Bomb Battle is a modern <strong>Bomberman clone</strong> built for 2024. It keeps the beloved grid-based
            explosive gameplay
            but removes the friction. No accounts. No loading screens. Just pure arcade adrenaline.
            It is designed as a "pick-up-and-play" <span class="keyword-highlight">rage game</span> where skill meets
            unfair RNG mechanics.
          </p>
        </section>

        <section id="unfair-mode">
          <h2>‚ò†Ô∏è Why This Game Is "Unfair"</h2>
          <p>
            Inspired by rage classics like <em>Unfair Mario</em>, our unique <strong>Unfair Mode</strong> (toggled via
            the skull button)
            breaks the rules of fair play. If you are looking for a standard <strong>play bomberman in browser</strong>
            experience,
            stick to Level 1. But if you want a challenge, Unfair Mode introduces:
          </p>
          <ul>
            <li><strong>Lying Bombs:</strong> Some bombs explode instantly, others take forever. You never know the fuse
              time.</li>
            <li><strong>Fake Power-ups:</strong> That Speed Up item? It might just kill you.</li>
            <li><strong>Ghost Enemies:</strong> Enemies that phase through walls to corner you.</li>
            <li><strong>Random Betrayal:</strong> Floor tiles that turn into traps without warning.</li>
          </ul>
        </section>

        <section id="game-modes">
          <h2>üéÆ Game Modes</h2>
          <h3>1. Single Player Saga</h3>
          <p>
            Battle through increasing waves of enemies. From the classic Ballom to the terrifying <strong>Ghost
              Blobs</strong> and the
            Level 5 Boss, "The Iron Bull". Can you survive without losing your lives?
          </p>

          <h3>2. Local Multiplayer PvP</h3>
          <p>
            Grab a friend and share the keyboard! Our <strong>multiplayer bomberman web game</strong> mode lets two
            players battle
            on the same screen.
            <br><strong>P1 (Blue):</strong> WASD to Move, SPACE to Bomb.
            <br><strong>P2 (Red):</strong> Arrows to Move, ENTER to Bomb.
          </p>
        </section>

        <section id="instant-play">
          <h2>üöÄ Play Instantly (No Login, No Download)</h2>
          <p>
            We believe games should be accessible. This is a <strong>no login web game</strong>.
            Unlike other sites that bury gameplay behind ads or registration walls, Bomb Battle loads in milliseconds.
            It is fully responsive and works on Chrome, Firefox, Edge, and Safari.
          </p>
        </section>

        <section id="difference">
          <h2>‚ö° Different From Classic Bomberman</h2>
          <p>
            While we honor the retro roots of the <em>bomberman clone</em> genre, we've added modern twists:
            <br>- <strong>Chain Reactions:</strong> Explosions trigger other bombs, creating massive combos.
            <br>- <strong>Remote Detonators:</strong> Control exactly when your traps go off.
            <br>- <strong>Smart AI:</strong> Enemies that actively hunt you down.
          </p>
          <p>
            Ready to blow stuff up? Scroll up and click <strong>Play</strong> now!
          </p>
        </section>

        <p style="font-size:0.8rem; color:#666; margin-top:50px;">
          <em>Disclaimer: This is a fan-made project created for educational purposes. It is not affiliated with Konami
            Digital Entertainment.</em>
        </p>
      </article>
    </div>
    <div id="ad-right" class="ad-slot">Right Ad (200px)</div>

    <!-- Credits -->
    <a href="https://www.linkedin.com/in/saurao-dalvi/" target="_blank" style="
        position: fixed; bottom: 10px; right: 10px; 
        color: rgba(255,255,255,0.4); font-size: 12px; text-decoration: none; 
        font-family: sans-serif; pointer-events: auto; z-index: 9999;
        transition: color 0.2s;
    " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='rgba(255,255,255,0.4)'">
      Created by Saurao Dalvi
    </a>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
    // Simple LCG for seeded random numbers
    class SimpleRNG {
      constructor(seed) { this.state = seed || 1; }
      next() {
        this.state = (this.state * 48271) % 2147483647;
        return (this.state - 1) / 2147483646;
      }
    }

    const GRID_SIZE = 13;
    const TILE_SIZE = 48;
    const WORLD_W = GRID_SIZE * TILE_SIZE;
    const WORLD_H = GRID_SIZE * TILE_SIZE;

    function tileToWorldCenter(tileX, tileY) {
      return {
        x: tileX * TILE_SIZE + TILE_SIZE / 2,
        y: tileY * TILE_SIZE + TILE_SIZE / 2,
      };
    }

    function worldToTile(worldX, worldY) {
      return {
        tileX: Phaser.Math.Clamp(Math.floor(worldX / TILE_SIZE), 0, GRID_SIZE - 1),
        tileY: Phaser.Math.Clamp(Math.floor(worldY / TILE_SIZE), 0, GRID_SIZE - 1),
      };
    }

    function isIndestructibleWall(tileX, tileY) {
      const max = GRID_SIZE - 1;
      if (tileX === 0 || tileY === 0 || tileX === max || tileY === max) return true;
      if (tileX % 2 === 0 && tileY % 2 === 0) return true;
      return false;
    }

    function isSpawnSafe(tileX, tileY) {
      // Player spawn at (1,1) with two adjacent safe tiles.
      if (tileX === 1 && tileY === 1) return true;
      if (tileX === 1 && tileY === 2) return true;
      if (tileX === 2 && tileY === 1) return true;
      return false;
    }

    class UnfairSystem {
      constructor(scene) {
        this.scene = scene;
        scene.cameras.main.setBackgroundColor('#1a0505'); // Evil tint
        this.scene.add.text(WORLD_W / 2, 40, "UNFAIR MODE ACTIVATED", { fontSize: '14px', color: '#330000', fontStyle: 'bold' }).setOrigin(0.5).setAlpha(0.5);
      }
      update(t, d) {
        if (Math.random() < 0.005) this.scene.cameras.main.shake(100, 0.001); // Subtle unease
        // Betrayal Tile
        if (Math.random() < 0.005) {
          const tx = Phaser.Math.Clamp(this.scene.playerTileX + Phaser.Math.Between(-3, 3), 1, GRID_SIZE - 2);
          const ty = Phaser.Math.Clamp(this.scene.playerTileY + Phaser.Math.Between(-3, 3), 1, GRID_SIZE - 2);
          const pos = tileToWorldCenter(tx, ty);
          const r = this.scene.add.rectangle(pos.x, pos.y, TILE_SIZE, TILE_SIZE, 0xff0000, 0).setDepth(0);
          this.scene.tweens.add({
            targets: r, alpha: 0.5, duration: 800, yoyo: true,
            onYoyo: () => {
              if (this.scene.playerTileX === tx && this.scene.playerTileY === ty) {
                this.scene.damagePlayer('p1');
                const t = this.scene.add.text(pos.x, pos.y - 20, "NICE TRY", { fontSize: '12px', color: '#f00', fontStyle: 'bold' }).setOrigin(0.5);
                this.scene.tweens.add({ targets: t, alpha: 0, y: t.y - 20, duration: 1000, onComplete: () => t.destroy() });
              }
            },
            onComplete: () => r.destroy()
          });
        }
      }
      getBombConfig() {
        const r = Math.random();
        // Unfair Fuses: Short (15%), Long (15%), Nuke (5%), Normal (65%)
        if (r < 0.15) return { fuse: 800, color: 0xff4f4f };
        if (r < 0.30) return { fuse: 3500, color: 0x330000 };
        if (r < 0.35) return { rad: 10, color: 0xffd36b };
        return null;
      }
      checkTrap(p) {
        if (p.isTrap) {
          this.scene.damagePlayer('p1');
          const t = this.scene.add.text(p.sprite.x, p.sprite.y - 20, "FAKE!", { fontSize: '14px', color: '#f00', fontStyle: 'bold', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
          this.scene.tweens.add({ targets: t, y: t.y - 40, alpha: 0, duration: 1000 });
          return true;
        }
        return false;
      }
    }

    class GameScene extends Phaser.Scene {
      constructor() {
        super({ key: 'GameScene' });
      }

      init(data) {
        this.mpState = null;
        this.localMp = data.localMp || false;
        this.level = data.level || 1;
        this.savedStats = data.stats || null;
        this.isUnfair = data.unfair || false;
      }

      spawnEnemies() {
        // Disable enemies in multiplayer (PvP focus)
        if (this.localMp) return;

        // Boss Level Check (Every 5 levels)
        if (this.level % 5 === 0 && this.level > 0) {
          this.spawnBoss();
          return;
        }

        // Spawn 2-4 enemies in safe corners (not overlapping player).
        const corners = [
          { x: GRID_SIZE - 2, y: 1 },
          { x: 1, y: GRID_SIZE - 2 },
          { x: GRID_SIZE - 2, y: GRID_SIZE - 2 },
          { x: 1, y: 1 },
        ];

        // Never spawn on player's exact tile.
        const filtered = corners.filter(c => !(c.x === this.playerTileX && c.y === this.playerTileY));
        Phaser.Utils.Array.Shuffle(filtered);

        // Scale difficulty with level
        const baseCount = 2 + Math.floor((this.level - 1) * 0.5);
        const enemyCount = Phaser.Math.Between(baseCount, baseCount + 1);
        const speedBase = Math.max(60, 140 - (this.level * 8)); // Faster each level

        const spawnList = filtered.slice(0, enemyCount);

        for (const s of spawnList) {
          // If a destructible block is occupying the spawn, clear it.
          if (this.blockByTile.has(`${s.x},${s.y}`)) {
            this.destroyBlockAt(s.x, s.y);
          }

          const pos = tileToWorldCenter(s.x, s.y);
          const shadow = this.add.image(pos.x, pos.y + 14, 'shadow');
          shadow.setDepth(2.5);

          const sprite = this.add.sprite(pos.x, pos.y, 'enemy');
          sprite.setDepth(3);
          sprite.play('enemy-idle');

          // Ghost Logic (Level 2+)
          let type = 'normal';
          if (this.level >= 2 && Math.random() < 0.4) {
            type = 'ghost';
            sprite.setTint(0x00ffff); // Cyan
            sprite.setAlpha(0.85);
          }

          this.enemies.push({
            sprite,
            shadow,
            tileX: s.x,
            tileY: s.y,
            isMoving: false,
            dir: Phaser.Math.RND.pick(['left', 'right', 'up', 'down']),
            dead: false,
            moveMs: speedBase + Phaser.Math.Between(0, 20),
            type: type,
            hp: 1
          });
        }
      }

      spawnBoss() {
        const pos = tileToWorldCenter(GRID_SIZE - 2, GRID_SIZE - 2);

        const shadow = this.add.image(pos.x, pos.y + 20, 'shadow').setScale(2);
        shadow.setDepth(2.5);

        const sprite = this.add.sprite(pos.x, pos.y, 'boss-bull');
        sprite.setDepth(3.5);
        sprite.setScale(1.5); // Huge

        this.enemies.push({
          sprite, shadow,
          tileX: GRID_SIZE - 2,
          tileY: GRID_SIZE - 2,
          isMoving: false,
          dir: 'left',
          dead: false,
          moveMs: 180, // Slow start
          type: 'boss',
          hp: 5,
          isBoss: true
        });

        // Boss Intro text
        const t = this.add.text(WORLD_W / 2, WORLD_H / 2, "WARNING: BOSS APPROACHING", { fontSize: '20px', color: '#f00', fontStyle: '900', stroke: '#000', strokeThickness: 4 }).setOrigin(0.5);
        this.tweens.add({ targets: t, alpha: 0, duration: 3000, onComplete: () => t.destroy() });
      }

      updateEnemies() {
        for (const e of this.enemies) {
          if (!e || e.dead) continue;

          // Update shadow follow in case of tween drift.
          e.shadow.x = e.sprite.x;
          e.shadow.y = e.sprite.y + 14;

          // Contact damage (tile overlap)
          if (!this.isInvulnerable && e.tileX === this.playerTileX && e.tileY === this.playerTileY) {
            this.damagePlayer('p1');
          }

          if (e.isMoving) continue;

          // Try to continue in same direction; if blocked, pick a new one.
          const attemptDirs = this.getEnemyAttemptDirs(e.dir);
          let moved = false;
          for (const dir of attemptDirs) {
            const d = this.dirToDelta(dir);
            const nx = e.tileX + d.dx;
            const ny = e.tileY + d.dy;

            // Boss Wall Smash Logic
            if (e.isBoss && this.blockByTile.has(`${nx},${ny}`)) {
              this.destroyBlockAt(nx, ny);
              this.cameras.main.shake(50, 0.002); // Stomp effect
            }

            if (this.isTileWalkableForEnemy(nx, ny, e)) {
              e.dir = dir;
              this.moveEnemyToTile(e, nx, ny);
              moved = true;
              break;
            }
          }

          if (!moved) {
            // stuck; randomize direction for next tick
            e.dir = Phaser.Math.RND.pick(['left', 'right', 'up', 'down']);
          }
        }
      }

      getEnemyAttemptDirs(primaryDir) {
        const dirs = ['left', 'right', 'up', 'down'];
        const rest = dirs.filter(d => d !== primaryDir);
        Phaser.Utils.Array.Shuffle(rest);
        return [primaryDir, ...rest];
      }

      dirToDelta(dir) {
        if (dir === 'left') return { dx: -1, dy: 0 };
        if (dir === 'right') return { dx: 1, dy: 0 };
        if (dir === 'up') return { dx: 0, dy: -1 };
        return { dx: 0, dy: 1 };
      }

      isTileWalkableForEnemy(tileX, tileY, enemy) {
        if (tileX < 0 || tileY < 0 || tileX >= GRID_SIZE || tileY >= GRID_SIZE) return false;
        if (isIndestructibleWall(tileX, tileY)) return false;

        // Ghost Enemy passes through soft blocks
        if (enemy && enemy.type === 'ghost') {
          // Can pass block
        } else {
          if (this.blockByTile.has(`${tileX},${tileY}`)) return false;
        }

        // Enemies treat any bomb as solid (even unarmed) to avoid camping it.
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tileX && b.tileY === tileY) return false;
        }

        // Avoid other enemies
        for (const other of this.enemies) {
          if (!other.dead && other.tileX === tileX && other.tileY === tileY) return false;
        }

        return true;
      }

      moveEnemyToTile(enemy, tileX, tileY) {
        enemy.isMoving = true;
        const to = tileToWorldCenter(tileX, tileY);

        this.tweens.add({
          targets: [enemy.sprite, enemy.shadow],
          x: to.x,
          y: (target) => (target === enemy.shadow ? to.y + 14 : to.y),
          duration: enemy.moveMs,
          ease: 'Linear',
          onComplete: () => {
            enemy.tileX = tileX;
            enemy.tileY = tileY;
            enemy.isMoving = false;

            // Check immediate contact after moving.
            if (!this.isInvulnerable && enemy.tileX === this.playerTileX && enemy.tileY === this.playerTileY) {
              this.damagePlayer('p1');
            }
          }
        });
      }

      preload() {
        // Stage 1 uses generated textures (placeholders). No external assets required.
      }

      create() {
        this.createTextures();

        this.physics.world.setBounds(0, 0, WORLD_W, WORLD_H);

        // Stage 6 UI overlay
        if (!this.scene.isActive('UIScene')) {
          this.scene.launch('UIScene');
        }
        this.scene.bringToTop('UIScene');

        if (this.isUnfair) {
          this.unfairSystem = new UnfairSystem(this);
        }

        this.floorImages = [];
        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const pos = tileToWorldCenter(x, y);
            const img = this.add.image(pos.x, pos.y, 'floor');
            img.setDepth(0);
            this.floorImages.push(img);
          }
        }

        this.walls = this.physics.add.staticGroup();
        this.blocks = this.physics.add.staticGroup();
        this.blockByTile = new Map();

        this.bombs = this.physics.add.staticGroup();
        this.activeBombs = [];

        this.explosions = this.add.group();
        this.blastRadius = 2;

        this.enemies = [];

        this.powerUps = [];
        this.powerUpByTile = new Map();

        const rng = this.mpState ? new SimpleRNG(this.mpState.seed) : Math;

        for (let y = 0; y < GRID_SIZE; y++) {
          for (let x = 0; x < GRID_SIZE; x++) {
            const pos = tileToWorldCenter(x, y);

            if (isIndestructibleWall(x, y)) {
              const wall = this.walls.create(pos.x, pos.y, 'wall');
              wall.setDepth(2);
              continue;
            }

            if (!isSpawnSafe(x, y)) {
              // Destructible blocks on empty tiles (50% chance)
              // Use seeded RNG if multiplayer
              if (rng === Math ? Math.random() < 0.5 : rng.next() < 0.5) {
                const block = this.blocks.create(pos.x, pos.y, 'block');
                block.setDepth(2);
                this.blockByTile.set(`${x},${y}`,
                  { sprite: block, tileX: x, tileY: y }
                );
              }
            }
          }
        }

        // Multiplayer Setup
        this.mpState = null;

        // --- PLAYER 1 SETUP ---
        this.playerTileX = 1;
        this.playerTileY = 1;
        const spawn1 = tileToWorldCenter(1, 1);

        this.playerShadow = this.add.image(spawn1.x, spawn1.y + 14, 'shadow');
        this.playerShadow.setDepth(2.5);

        this.player = this.add.sprite(spawn1.x, spawn1.y, 'player');
        this.player.setDepth(3);
        this.player.setTint(0x8888ff); // Blue
        this.isMovingP1 = false;
        this.lastBombP1 = false;
        this.livesP1 = (this.savedStats && this.savedStats.lives) ? this.savedStats.lives : 3;
        this.maxBombsP1 = this.savedStats ? this.savedStats.bombs : 1;
        this.blastRadiusP1 = this.savedStats ? this.savedStats.radius : 2;
        this.speedMsP1 = this.savedStats ? this.savedStats.speed : 120;
        this.speedMsP1 = this.savedStats ? this.savedStats.speed : 120;
        this.hasRemoteP1 = this.savedStats ? this.savedStats.remote : false;

        const dBtn = document.getElementById('m-detonate');
        if (dBtn) dBtn.style.display = this.hasRemoteP1 ? 'flex' : 'none';

        this.levelComplete = false;

        // Level Announce
        if (!this.localMp) {
          const txt = this.add.text(WORLD_W / 2, WORLD_H / 2, 'LEVEL ' + this.level, { fontSize: '48px', color: '#fff', fontStyle: '900', stroke: '#000', strokeThickness: 8 }).setOrigin(0.5).setDepth(2000);
          this.tweens.add({ targets: txt, alpha: 0, scale: 1.5, duration: 1800, delay: 500, onComplete: () => txt.destroy() });
        }

        // --- PLAYER 2 SETUP (Local MP) ---
        this.player2 = null;
        if (this.localMp) {
          const spawn2 = tileToWorldCenter(GRID_SIZE - 2, GRID_SIZE - 2);

          this.player2Shadow = this.add.image(spawn2.x, spawn2.y + 14, 'shadow');
          this.player2Shadow.setDepth(2.5);

          this.player2 = this.add.sprite(spawn2.x, spawn2.y, 'player');
          this.player2.setDepth(3);
          this.player2.setTint(0xff8888); // Red

          this.player2TileX = GRID_SIZE - 2;
          this.player2TileY = GRID_SIZE - 2;
          this.isMovingP2 = false;
          this.lastBombP2 = false;
          this.livesP2 = 3;
          this.maxBombsP2 = 1;
          this.blastRadiusP2 = 2;
          this.speedMsP2 = 120;
        }

        // Use addKeys for arrows to avoid binding SPACE/SHIFT automatically via createCursorKeys
        this.cursors = this.input.keyboard.addKeys({
          up: Phaser.Input.Keyboard.KeyCodes.UP,
          down: Phaser.Input.Keyboard.KeyCodes.DOWN,
          left: Phaser.Input.Keyboard.KeyCodes.LEFT,
          right: Phaser.Input.Keyboard.KeyCodes.RIGHT
        });

        // Virtual Keys (for Mobile / Touch)
        this.virtualKeys = { up: false, down: false, left: false, right: false, bomb: false, detonate: false };
        window.updateBmInput = (k, v) => { if (this.virtualKeys) this.virtualKeys[k] = v; };

        const inputKeys = this.input.keyboard.addKeys('W,A,S,D,SPACE,ENTER,E');
        this.keys = inputKeys;
        this.spaceKey = inputKeys.SPACE;
        this.enterKey = inputKeys.ENTER;
        this.keyE = inputKeys.E;

        // Explicitly capture keys to prevent browser scrolling
        this.input.keyboard.addCapture([
          Phaser.Input.Keyboard.KeyCodes.SPACE,
          Phaser.Input.Keyboard.KeyCodes.ENTER,
          Phaser.Input.Keyboard.KeyCodes.UP,
          Phaser.Input.Keyboard.KeyCodes.DOWN,
          Phaser.Input.Keyboard.KeyCodes.LEFT,
          Phaser.Input.Keyboard.KeyCodes.RIGHT,
          Phaser.Input.Keyboard.KeyCodes.W,
          Phaser.Input.Keyboard.KeyCodes.A,
          Phaser.Input.Keyboard.KeyCodes.S,
          Phaser.Input.Keyboard.KeyCodes.D
        ]);

        // Make sure the canvas can be focused
        const canvas = this.game.canvas;
        canvas.setAttribute('tabindex', '0');
        canvas.style.outline = 'none';
        this.input.on('pointerdown', () => canvas.focus());

        this.cameras.main.setBounds(0, 0, WORLD_W, WORLD_H);
        this.cameras.main.centerOn(WORLD_W / 2, WORLD_H / 2);

        this.score = 0;
        this.isInvulnerable = false;
        this.emitUiState();

        this.particles = this.add.particles(0, 0, 'particle');
        this.particles.setDepth(50);

        this.debrisParticles = this.add.particles(0, 0, 'debris-1');
        this.debrisParticles.setDepth(49);

        this.spawnEnemies();

        // Stage 7: Vignette Overlay
        this.vignette = this.add.image(WORLD_W / 2, WORLD_H / 2, 'vignette');
        this.vignette.setDepth(100);
        this.vignette.setScrollFactor(0);

        // Stage 7: Intro Zoom
        this.cameras.main.setZoom(1.2);
        this.tweens.add({
          targets: this.cameras.main,
          zoom: 1,
          duration: 800,
          ease: 'Cubic.easeOut'
        });

        // Backup Input Hook: forces bomb placement if standard input fails (e.g. lost focus)
        window.__bmPlaceBomb = () => {
          if (this.livesP1 > 0) {
            console.log('Global Space Hook Triggered');
            this.tryPlaceBomb('p1');
          }
        };
        this.events.once(Phaser.Scenes.Events.SHUTDOWN, () => {
          window.__bmPlaceBomb = null;
        });
      }

      update(time, delta) {
        // --- PLAYER 1 (WASD + Space) ---
        if (this.livesP1 > 0) {
          this.handlePlayerInput(this.player, 'p1', this.keys.W, this.keys.A, this.keys.S, this.keys.D, this.spaceKey);
          // Detonate Check
          if ((Phaser.Input.Keyboard.JustDown(this.keyE) || this.virtualKeys.detonate) && this.hasRemoteP1) {
            this.detonateRemoteBomb('p1');
            this.virtualKeys.detonate = false; // Reset virtual press
          }
          this.playerShadow.x = this.player.x;
          this.playerShadow.y = this.player.y + 14;
        } else {
          this.player.setVisible(false);
          this.playerShadow.setVisible(false);
        }

        // --- PLAYER 2 (Arrows + Enter) ---
        if (this.localMp && this.player2 && this.livesP2 > 0) {
          this.handlePlayerInput(this.player2, 'p2', this.cursors.up, this.cursors.left, this.cursors.down, this.cursors.right, this.enterKey);
          this.player2Shadow.x = this.player2.x;
          this.player2Shadow.y = this.player2.y + 14;
        } else if (this.player2) {
          this.player2.setVisible(false);
          this.player2Shadow.setVisible(false);
        }

        // Arm bombs
        for (const b of this.activeBombs) {
          if (!b.armed) {
            let safe = true;
            if (this.livesP1 > 0 && this.isOverlapping(this.player, b.sprite)) safe = false;
            if (this.localMp && this.livesP2 > 0 && this.isOverlapping(this.player2, b.sprite)) safe = false;

            if (safe) {
              b.armed = true;
              if (b.sprite.body) b.sprite.body.checkCollision.none = false;
            }
          }
        }

        this.updateEnemies();
        if (this.unfairSystem) this.unfairSystem.update(time, delta);
      }

      isOverlapping(spriteA, spriteB) {
        if (!spriteA.visible || !spriteB.visible) return false;
        const d = Phaser.Math.Distance.Between(spriteA.x, spriteA.y, spriteB.x, spriteB.y);
        return d < TILE_SIZE * 0.45;
      }

      handlePlayerInput(sprite, pid, kUp, kLeft, kDown, kRight, kBomb) {
        const isMoving = (pid === 'p1') ? this.isMovingP1 : this.isMovingP2;

        if (!isMoving) {
          let dx = 0, dy = 0, dir = null;
          // Input: Check Physical Keys OR Virtual Keys
          if (kLeft.isDown || this.virtualKeys.left) { dx = -1; dy = 0; dir = 'left'; }
          else if (kRight.isDown || this.virtualKeys.right) { dx = 1; dy = 0; dir = 'right'; }
          else if (kUp.isDown || this.virtualKeys.up) { dx = 0; dy = -1; dir = 'up'; }
          else if (kDown.isDown || this.virtualKeys.down) { dx = 0; dy = 1; dir = 'down'; }

          if (dx !== 0 || dy !== 0) {
            this.tryMoveByTile(pid, dx, dy, dir);
          } else {
            sprite.anims.stop();
            sprite.setFrame(this.getIdleFrameForDir(dir || 'down'));
          }
        }

        // Bomb Input: Physical OR Virtual
        const isBombDown = kBomb.isDown || this.virtualKeys.bomb;
        const keyStateName = 'lastBomb' + pid.toUpperCase(); // lastBombP1 or lastBombP2

        if (isBombDown && !this[keyStateName]) {
          this.tryPlaceBomb(pid);
          this[keyStateName] = true;
        }
        if (!isBombDown) {
          this[keyStateName] = false;
        }
      }

      tryMoveByTile(pid, dx, dy, dir) {
        const pTileX = (pid === 'p1') ? this.playerTileX : this.player2TileX;
        const pTileY = (pid === 'p1') ? this.playerTileY : this.player2TileY;
        const sprite = (pid === 'p1') ? this.player : this.player2;
        const shadow = (pid === 'p1') ? this.playerShadow : this.player2Shadow;
        const moveMs = (pid === 'p1') ? this.speedMsP1 : this.speedMsP2;

        const nx = pTileX + dx;
        const ny = pTileY + dy;

        if (nx < 0 || ny < 0 || nx >= GRID_SIZE || ny >= GRID_SIZE) return;
        if (!this.isTileWalkable(nx, ny)) return;

        if (pid === 'p1') this.isMovingP1 = true;
        else this.isMovingP2 = true;

        const to = tileToWorldCenter(nx, ny);
        sprite.anims.play('walk-' + dir, true);

        this.tweens.add({
          targets: [sprite, shadow],
          x: to.x,
          y: (target) => (target === shadow ? to.y + 14 : to.y),
          duration: moveMs,
          ease: 'Linear',
          onComplete: () => {
            if (pid === 'p1') {
              this.playerTileX = nx;
              this.playerTileY = ny;
              this.isMovingP1 = false;
              this.tryCollectPowerUpAt(nx, ny, 'p1');
            } else {
              this.player2TileX = nx;
              this.player2TileY = ny;
              this.isMovingP2 = false;
              this.tryCollectPowerUpAt(nx, ny, 'p2');
            }
          }
        });
      }

      isTileWalkable(tileX, tileY) {
        if (isIndestructibleWall(tileX, tileY)) return false;
        if (this.blockByTile.has(`${tileX},${tileY}`)) return false;
        // Bombs are solid once armed
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tileX && b.tileY === tileY) {
            return b.armed === false;
          }
        }
        return true;
      }

      getIdleFrameForDir(dir) {
        const idxByDir = { down: 0, left: 4, right: 8, up: 12 };
        return idxByDir[dir] ?? 0;
      }

      tryPlaceBomb(pid) {
        const tx = (pid === 'p1') ? this.playerTileX : this.player2TileX;
        const ty = (pid === 'p1') ? this.playerTileY : this.player2TileY;
        const maxB = (pid === 'p1') ? this.maxBombsP1 : this.maxBombsP2;
        const blastR = (pid === 'p1') ? this.blastRadiusP1 : this.blastRadiusP2;

        if (isIndestructibleWall(tx, ty)) return;

        // Count ACTIVE bombs owned by this player
        const activeCount = this.activeBombs.filter(b => b && !b.exploded && b.owner === pid).length;
        if (activeCount >= maxB) return;

        // No stacking
        for (const b of this.activeBombs) {
          if (!b.exploded && b.tileX === tx && b.tileY === ty) return;
        }

        const pos = tileToWorldCenter(tx, ty);
        if (this.blockByTile.has(`${tx},${ty}`)) return;

        const bombSprite = this.bombs.create(pos.x, pos.y, 'bomb');
        bombSprite.setDepth(2.8);
        bombSprite.body.checkCollision.none = true;

        const bomb = {
          sprite: bombSprite,
          tileX: tx,
          tileY: ty,
          armed: false,
          exploded: false,
          owner: pid,
          radius: blastR,
          glow: null
        };
        this.activeBombs.push(bomb);

        // Glow
        const glow = this.add.image(pos.x, pos.y + 2, 'soft-glow');
        glow.setDepth(2.7);
        glow.setTint(0xff6b4f);
        glow.setAlpha(0.6);
        glow.setScale(1.2);
        bomb.glow = glow;

        if (this.isUnfair && this.unfairSystem) {
          const cfg = this.unfairSystem.getBombConfig();
          if (cfg) {
            if (cfg.fuse) bomb.customFuse = cfg.fuse;
            if (cfg.rad) bomb.radius = cfg.rad;
            if (cfg.color) bombSprite.setTint(cfg.color);
          }
        }

        this.tweens.add({ targets: glow, alpha: 0.2, scale: 1.5, duration: 500, yoyo: true, repeat: -1 });
        this.tweens.add({ targets: bombSprite, scale: { from: 1, to: 1.08 }, duration: 220, yoyo: true, repeat: -1 });

        const fuseTime = bomb.customFuse || 2400;

        // Remote Logic: If player has remote, NO auto-explode (unless customUnfairFuse override)
        if (pid === 'p1' && this.hasRemoteP1 && !bomb.customFuse) {
          bomb.isRemote = true;
          bomb.sprite.setTint(0xd67cff); // Purple tint for remote bombs
        } else {
          this.time.delayedCall(fuseTime, () => this.explodeBomb(bomb));
        }
      }

      detonateRemoteBomb(pid) {
        // Explode the oldest active remote bomb owned by this player
        const b = this.activeBombs.find(x => x && !x.exploded && x.owner === pid && x.isRemote);
        if (b) this.explodeBomb(b);
      }

      explodeBomb(bomb) {
        if (!bomb || bomb.exploded) return;
        bomb.exploded = true;

        const bombSprite = bomb.sprite;
        if (bombSprite && bombSprite.active) {
          this.tweens.killTweensOf(bombSprite);
          bombSprite.destroy();
        }

        if (bomb.glow) {
          this.tweens.killTweensOf(bomb.glow);
          bomb.glow.destroy();
        }

        const tiles = this.getExplosionTiles(bomb.tileX, bomb.tileY, bomb.radius);

        this.cameras.main.shake(120, 0.006);

        for (const t of tiles) {
          const pos = tileToWorldCenter(t.tileX, t.tileY);

          const exp = this.add.image(pos.x, pos.y, 'explosion');
          exp.setBlendMode(Phaser.BlendModes.ADD);
          exp.setDepth(10);
          this.explosions.add(exp);

          this.tweens.add({
            targets: exp,
            alpha: { from: 0.95, to: 0 },
            scale: { from: 0.9, to: 1.35 },
            duration: 260,
            ease: 'Quad.easeOut',
            onComplete: () => exp.destroy(),
          });

          this.emitExplosionParticles(pos.x, pos.y);

          if (t.hitBlock) {
            this.destroyBlockAt(t.tileX, t.tileY);
          }
          this.killEnemiesAtTile(t.tileX, t.tileY);

          // Chain Reaction: Check for other bombs
          for (const otherB of this.activeBombs) {
            if (!otherB.exploded && otherB.tileX === t.tileX && otherB.tileY === t.tileY) {
              // Slight delay for visual ripple effect
              this.time.delayedCall(100, () => this.explodeBomb(otherB));
            }
          }
        }

        this.checkPlayerDamage(tiles);
      }

      killEnemiesAtTile(tileX, tileY) {
        for (const e of this.enemies) {
          if (!e || e.dead) continue;
          if (e.tileX !== tileX || e.tileY !== tileY) continue;

          e.dead = true;
          e.isMoving = false;

          if (e.isBoss) {
            e.hp--;
            if (e.hp > 0) {
              e.dead = false; // Not dead yet!
              e.isMoving = false; // Brief stun
              e.sprite.setTint(0xff0000); // Angry red
              this.tweens.add({
                targets: e.sprite,
                alpha: 0.2, duration: 100, yoyo: true, repeat: 3,
                onComplete: () => {
                  e.isMoving = false;
                  if (e.hp <= 2) { e.moveMs = 80; e.sprite.setTint(0xff5555); } // Rage Mode
                  else e.sprite.clearTint();
                }
              });
              // Stun delay
              this.time.delayedCall(400, () => { if (e.hp > 0) e.dead = false; });
              return; // Don't destroy
            }
            // Boss Death
            this.score += 5000;
            this.showToast("BOSS DEFEATED!");
            this.emitEnemyDeathParticles(e.sprite.x, e.sprite.y);
            // Drop Remote
            this.maybeSpawnPowerUp(e.tileX, e.tileY, 'remote');
            e.sprite.destroy();
            e.shadow.destroy();
            // Win Level immediately
            this.winLevel();
            return;
          }

          this.score += 100;
          this.emitUiState();
          this.emitEnemyDeathParticles(e.sprite.x, e.sprite.y);
          e.sprite.destroy();
          e.shadow.destroy();

          if (!this.localMp && this.enemies.filter(en => !en.dead).length === 0) {
            this.winLevel();
          }
        }
      }

      winLevel() {
        if (this.levelComplete) return;
        this.levelComplete = true;
        this.isInvulnerable = true;

        const txt = this.add.text(WORLD_W / 2, WORLD_H / 2, 'LEVEL COMPLETE!', { fontSize: '32px', color: '#ffd36b', fontStyle: '900', stroke: '#000', strokeThickness: 6 }).setOrigin(0.5);
        txt.setDepth(2000);
        this.tweens.add({ targets: txt, scale: { from: 0.5, to: 1.2 }, duration: 400, ease: 'Back.out' });

        this.time.delayedCall(2000, () => {
          this.scene.restart({
            level: this.level + 1,
            stats: { lives: this.livesP1, bombs: this.maxBombsP1, radius: this.blastRadiusP1, speed: this.speedMsP1, remote: this.hasRemoteP1 },
            localMp: false
          });
        });
      }

      emitEnemyDeathParticles(x, y) {
        this.particles.emitParticleAt(x, y, {
          quantity: 16,
          lifespan: { min: 220, max: 520 },
          speed: { min: 40, max: 180 },
          scale: { start: 0.9, end: 0 },
          alpha: { start: 0.85, end: 0 },
          tint: [0x7ce6ff, 0xffd36b, 0xffffff],
          blendMode: 'ADD',
        });
      }

      getExplosionTiles(originX, originY, radius) {
        const out = [];
        out.push({ tileX: originX, tileY: originY, hitBlock: false });

        const dirs = [{ dx: 1, dy: 0 }, { dx: -1, dy: 0 }, { dx: 0, dy: 1 }, { dx: 0, dy: -1 }];

        for (const d of dirs) {
          for (let i = 1; i <= radius; i++) {
            const tx = originX + d.dx * i;
            const ty = originY + d.dy * i;
            if (tx < 0 || ty < 0 || tx >= GRID_SIZE || ty >= GRID_SIZE) break;
            if (isIndestructibleWall(tx, ty)) break;

            const key = `${tx},${ty}`;
            if (this.blockByTile.has(key)) {
              out.push({ tileX: tx, tileY: ty, hitBlock: true });
              break;
            }
            out.push({ tileX: tx, tileY: ty, hitBlock: false });
          }
        }
        return out;
      }

      destroyBlockAt(tileX, tileY) {
        const key = `${tileX},${tileY}`;
        const block = this.blockByTile.get(key);
        if (!block) return;

        const s = block.sprite;
        this.blockByTile.delete(key);
        s.destroy();

        this.score += 10;
        this.emitUiState();

        const worldPos = tileToWorldCenter(tileX, tileY);
        this.emitBlockDebris(worldPos.x, worldPos.y);
        this.maybeSpawnPowerUp(tileX, tileY);
      }

      emitBlockDebris(x, y) {
        this.debrisParticles.emitParticleAt(x, y, {
          speed: { min: 50, max: 150 },
          lifespan: 600,
          gravityY: 200,
          quantity: 6,
          scale: { start: 0.8, end: 0.4 }
        });
      }

      maybeSpawnPowerUp(tileX, tileY) {
        if (this.powerUpByTile.has(`${tileX},${tileY}`)) return;
        if (Math.random() > 0.30) return;

        const r = Math.random();
        let type = 'bomb';
        if (r < 0.40) type = 'bomb';
        else if (r < 0.70) type = 'radius';
        else if (r < 0.90) type = 'speed';
        else type = 'remote';

        const pos = tileToWorldCenter(tileX, tileY);
        const shadow = this.add.image(pos.x, pos.y + 14, 'shadow');
        shadow.setDepth(2.55);

        const key = type === 'bomb' ? 'powerup-bomb' : type === 'radius' ? 'powerup-radius' : type === 'speed' ? 'powerup-speed' : 'powerup-remote';
        const sprite = this.add.image(pos.x, pos.y, key);
        sprite.setDepth(3.1);

        const powerUp = { type, tileX, tileY, sprite, shadow, isTrap: false };
        // Unfair Trap Logic
        if (this.isUnfair && Math.random() < 0.25) { // 25% trap rate
          powerUp.isTrap = true;
        }

        this.powerUps.push(powerUp);
        this.powerUpByTile.set(`${tileX},${tileY}`, powerUp);

        this.tweens.add({ targets: sprite, y: pos.y + 3, duration: 800, yoyo: true, repeat: -1 });
      }

      tryCollectPowerUpAt(tileX, tileY, pid) {
        const key = `${tileX},${tileY}`;
        const p = this.powerUpByTile.get(key);
        if (!p) return;

        if (this.isUnfair && this.unfairSystem && this.unfairSystem.checkTrap(p)) {
          // Trap triggered, remove it
          this.powerUpByTile.delete(key);
          p.sprite.destroy();
          p.shadow.destroy();
          return;
        }

        this.applyPowerUp(p.type, pid);
        this.powerUpByTile.delete(key);
        p.sprite.destroy();
        p.shadow.destroy();

        this.score += 25;
        this.emitUiState();
      }

      applyPowerUp(type, pid) {
        if (pid === 'p1') {
          if (type === 'bomb') this.maxBombsP1++;
          else if (type === 'radius') this.blastRadiusP1++;
          else if (type === 'speed') this.speedMsP1 = Math.max(65, this.speedMsP1 - 10);
          else if (type === 'remote') {
            this.hasRemoteP1 = true;
            this.showToast("REMOTE ACQUIRED! Press 'E'");
            const btn = document.getElementById('m-detonate');
            if (btn) btn.style.display = 'flex';
          }
        } else {
          if (type === 'bomb') this.maxBombsP2++;
          else if (type === 'radius') this.blastRadiusP2++;
          else if (type === 'speed') this.speedMsP2 = Math.max(65, this.speedMsP2 - 10);
        }
        this.emitUiState();
      }

      checkPlayerDamage(explosionTiles) {
        if (this.livesP1 > 0 && !this.isInvulnerable) {
          for (const t of explosionTiles) {
            if (t.tileX === this.playerTileX && t.tileY === this.playerTileY) {
              this.damagePlayer('p1');
              break;
            }
          }
        }
        if (this.localMp && this.player2 && this.livesP2 > 0) {
          for (const t of explosionTiles) {
            if (t.tileX === this.player2TileX && t.tileY === this.player2TileY) {
              this.damagePlayer('p2');
              break;
            }
          }
        }
      }

      damagePlayer(pid) {
        if (this.isInvulnerable) return;

        if (pid === 'p1') {
          if (this.livesP1 <= 0) return;
          this.livesP1--;
          this.emitUiState(); // Immediate update

          if (this.livesP1 <= 0) {
            this.handleGameOver();
            return;
          }

          // Respawn & Invulnerability (Single Player)
          this.isInvulnerable = true;
          const spawn = tileToWorldCenter(1, 1);
          this.playerTileX = 1; this.playerTileY = 1;
          this.player.setPosition(spawn.x, spawn.y);
          this.player.setAlpha(0.5);

          this.tweens.add({
            targets: this.player,
            alpha: 1,
            duration: 200,
            yoyo: true,
            repeat: 8,
            onComplete: () => {
              this.player.setAlpha(1);
              this.isInvulnerable = false;
            }
          });

          // Clear spawn safety
          this.emitBlockDebris(spawn.x, spawn.y);

        } else {
          // P2 Logic (Keep simple as requested focus is P1/General)
          this.livesP2--;
          this.emitUiState();
          if (this.livesP2 <= 0) {
            this.player2.setVisible(false);
            this.player2Shadow.setVisible(false);
            this.emitBlockDebris(this.player2.x, this.player2.y);
          } else {
            const spawn = tileToWorldCenter(GRID_SIZE - 2, GRID_SIZE - 2);
            this.player2TileX = GRID_SIZE - 2; this.player2TileY = GRID_SIZE - 2;
            this.player2.setPosition(spawn.x, spawn.y);
          }
        }
        this.cameras.main.shake(180, 0.012);
      }

      handleGameOver() {
        this.player.setVisible(false);
        this.playerShadow.setVisible(false);
        this.emitBlockDebris(this.player.x, this.player.y);
        this.physics.pause();

        // Game Over UI
        const cx = WORLD_W / 2;
        const cy = WORLD_H / 2;

        const ov = this.add.rectangle(cx, cy, WORLD_W, WORLD_H, 0x0b0f1a, 0.9).setInteractive();
        ov.setDepth(3000);

        const t1 = this.add.text(cx, cy - 50, 'GAME OVER', { fontSize: '48px', color: '#ff4f4f', fontStyle: '900', stroke: '#fff', strokeThickness: 6 }).setOrigin(0.5);
        t1.setDepth(3001);

        const t2 = this.add.text(cx, cy + 10, `Final Score: ${this.score}`, { fontSize: '24px', color: '#ffd36b', fontStyle: 'bold' }).setOrigin(0.5);
        t2.setDepth(3001);

        const btn = this.add.rectangle(cx, cy + 80, 180, 50, 0x3e4f73).setStrokeStyle(2, 0x7ce6ff);
        btn.setDepth(3001);
        const btnTxt = this.add.text(cx, cy + 80, 'TRY AGAIN', { fontSize: '20px', color: '#fff', fontStyle: 'bold' }).setOrigin(0.5);
        btnTxt.setDepth(3002);

        btn.setInteractive({ useHandCursor: true })
          .on('pointerdown', () => {
            this.scene.restart({ level: 1, stats: null, localMp: false });
          })
          .on('pointerover', () => btn.setFillStyle(0x4f6491))
          .on('pointerout', () => btn.setFillStyle(0x3e4f73));
      }

      emitUiState() {
        if (!this.game || !this.game.events) return;
        this.game.events.emit('ui:update', {
          lives: this.livesP1,
          livesP2: this.localMp ? this.livesP2 : null,
          localMp: this.localMp,
          score: this.score,
          maxBombs: this.maxBombsP1,
          blastRadius: this.blastRadiusP1,
          speed: this.speedMsP1
        });
      }

      emitExplosionParticles(x, y) {
        this.particles.emitParticleAt(x, y, {
          quantity: 14,
          lifespan: { min: 180, max: 420 },
          speed: { min: 40, max: 170 },
          scale: { start: 0.8, end: 0 },
          blendMode: 'ADD',
        });
      }

      setupMpEvents() {
        const socket = this.mpState.socket;

        socket.on('player:join', (data) => {
          this.createOtherPlayer(data.slot);
        });

        socket.on('player:leave', (data) => {
          if (this.otherPlayers[data.slot]) {
            this.otherPlayers[data.slot].destroy();
            delete this.otherPlayers[data.slot];
          }
        });

        socket.on('player:moved', (data) => {
          this.updateOtherPlayer(data.slot, data.x, data.y, data.anim, data.dir);
        });

        socket.on('game:placeBomb', (data) => {
          // If it's me, I already placed it. Only spawn for others.
          if (data.slot !== this.mpState.slot) {
            this.spawnRemoteBomb(data.tileX, data.tileY);
          }
        });
      }

      createOtherPlayer(slot) {
        if (this.otherPlayers[slot]) return;

        // Spawn remote player at default location or wait for updates
        // For simplicity, spawn at their home corner
        let tx = 1, ty = 1;
        if (slot === 'p2') { tx = GRID_SIZE - 2; ty = GRID_SIZE - 2; }

        const pos = tileToWorldCenter(tx, ty);
        const sprite = this.add.sprite(pos.x, pos.y, 'player');
        sprite.setDepth(3);
        if (slot === 'p2') sprite.setTint(0xff8888);
        else sprite.setTint(0x8888ff);

        this.otherPlayers[slot] = sprite;
      }

      updateOtherPlayer(slot, worldX, worldY, animKey, dir) {
        const p = this.otherPlayers[slot];
        if (!p) return;

        // Simple tween to new position
        this.tweens.add({
          targets: p,
          x: worldX,
          y: worldY,
          duration: this.tileMoveMs,
          ease: 'Linear'
        });

        if (animKey) {
          p.play(animKey, true);
        } else {
          p.anims.stop();
          p.setFrame(this.getIdleFrameForDir(dir || 'down'));
        }
      }

      spawnRemoteBomb(tileX, tileY) {
        // Force spawn a bomb at location, bypassing ownership checks/counts for local player
        const pos = tileToWorldCenter(tileX, tileY);
        const bombSprite = this.bombs.create(pos.x, pos.y, 'bomb');
        bombSprite.setDepth(2.8);
        bombSprite.body.checkCollision.none = true;

        const bomb = {
          sprite: bombSprite,
          tileX: tileX,
          tileY: tileY,
          armed: false,
          exploded: false,
          glow: null
        };
        this.activeBombs.push(bomb);

        // Add glow
        const glow = this.add.image(pos.x, pos.y + 2, 'soft-glow');
        glow.setDepth(2.7);
        glow.setTint(0xff6b4f);
        glow.setAlpha(0.6);
        glow.setScale(1.2);
        bomb.glow = glow;

        this.tweens.add({ targets: glow, alpha: 0.2, scale: 1.5, duration: 500, yoyo: true, repeat: -1 });
        this.tweens.add({ targets: bombSprite, scale: { from: 1, to: 1.08 }, duration: 220, yoyo: true, repeat: -1 });

        this.time.delayedCall(2400, () => this.explodeBomb(bomb));
      }

      createTextures() {
        if (!this.textures.exists('floor')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x162033, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 6);
          g.fillStyle(0x1f2d47, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 8, 6);
          g.fillStyle(0x0b0f1a, 0.25);
          g.fillRect(0, TILE_SIZE - 6, TILE_SIZE, 6);
          g.generateTexture('floor', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('wall')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x3e4f73, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0x556a93, 1);
          g.fillRoundedRect(4, 4, TILE_SIZE - 8, TILE_SIZE - 10, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0x6f86b0, 0.55);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('wall', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('block')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x8a5a3c, 1);
          g.fillRoundedRect(0, 0, TILE_SIZE, TILE_SIZE, 8);
          g.fillStyle(0xb3784f, 1);
          g.fillRoundedRect(5, 5, TILE_SIZE - 10, TILE_SIZE - 12, 8);
          g.fillStyle(0x0b0f1a, 0.35);
          g.fillRect(0, TILE_SIZE - 8, TILE_SIZE, 8);
          g.lineStyle(2, 0xe2b37c, 0.35);
          g.strokeRoundedRect(2, 2, TILE_SIZE - 4, TILE_SIZE - 4, 8);
          g.generateTexture('block', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('player')) {
          // Player placeholder
          const size = TILE_SIZE;
          const sheetKey = 'player-sheet';
          if (!this.textures.exists(sheetKey)) {
            // ...
          }
          // inline generation
          const tex = this.textures.createCanvas(sheetKey, size * 4, size * 4);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size * 4);

          const dirColors = {
            down: { main: '#3ee6a8', edge: 'rgba(182,255,231,0.75)' },
            left: { main: '#4fd0ff', edge: 'rgba(190,240,255,0.75)' },
            right: { main: '#ffb84f', edge: 'rgba(255,236,190,0.75)' },
            up: { main: '#d36bff', edge: 'rgba(245,210,255,0.75)' },
          };

          const roundRect = (context, x, y, w, h, r) => {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          };

          const drawFrame = (frameX, frameY, main, edge, step) => {
            const ox = frameX * size;
            const oy = frameY * size;
            ctx.clearRect(ox, oy, size, size);
            const cx = ox + size / 2;
            const cy = oy + size / 2 - 2;
            const wobble = (step === 1 ? -2 : step === 3 ? 2 : 0);
            const bob = (step === 2 ? 1 : 0);
            ctx.fillStyle = main;
            roundRect(ctx, cx - 14 + wobble, cy - 16 + bob, 28, 28, 10);
            ctx.fill();
            ctx.strokeStyle = edge;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8 + wobble, cy - 6 + bob, 16, 6);
          };

          Object.keys(dirColors).forEach((dir, row) => {
            // dirs: down, left, right, up
            // but object keys order is not guaranteed? 
            // safest to iterate array
          });

          ['down', 'left', 'right', 'up'].forEach((dir, row) => {
            const c = dirColors[dir];
            for (let col = 0; col < 4; col++) {
              drawFrame(col, row, c.main, c.edge, col);
            }
          });

          tex.refresh();
          this.textures.addSpriteSheet('player', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);
        }

        // ANIMS check
        if (!this.anims.exists('walk-down')) {
          this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('player', { start: 0, end: 3 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('player', { start: 4, end: 7 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('player', { start: 8, end: 11 }), frameRate: 10, repeat: -1 });
          this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('player', { start: 12, end: 15 }), frameRate: 10, repeat: -1 });
        }


        if (!this.textures.exists('enemy')) {
          const size = TILE_SIZE;
          const sheetKey = 'enemy-sheet';
          const tex = this.textures.createCanvas(sheetKey, size * 4, size);
          const ctx = tex.getContext();
          ctx.clearRect(0, 0, size * 4, size);

          const roundRect = (context, x, y, w, h, r) => {
            const rr = Math.min(r, w / 2, h / 2);
            context.beginPath();
            context.moveTo(x + rr, y);
            context.arcTo(x + w, y, x + w, y + h, rr);
            context.arcTo(x + w, y + h, x, y + h, rr);
            context.arcTo(x, y + h, x, y, rr);
            context.arcTo(x, y, x + w, y, rr);
            context.closePath();
          };

          for (let i = 0; i < 4; i++) {
            const ox = i * size;
            const cx = ox + size / 2;
            const cy = size / 2 - 2;
            const bob = (i === 1 ? 1 : i === 3 ? -1 : 0);
            const glow = (i === 2 ? 0.85 : 0.65);
            ctx.clearRect(ox, 0, size, size);
            ctx.fillStyle = `rgba(0,0,0,0.22)`;
            ctx.beginPath();
            ctx.ellipse(cx, cy + 28, 14, 8, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ff4f7e';
            roundRect(ctx, cx - 14, cy - 16 + bob, 28, 28, 10);
            ctx.fill();
            ctx.strokeStyle = `rgba(255,230,240,${glow})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = 'rgba(11,15,26,0.35)';
            ctx.fillRect(cx - 8, cy - 6 + bob, 16, 6);
          }
          tex.refresh();
          this.textures.addSpriteSheet('enemy', tex.getSourceImage(), { frameWidth: size, frameHeight: size });
          this.textures.remove(sheetKey);
        }

        if (!this.anims.exists('enemy-idle')) {
          this.anims.create({
            key: 'enemy-idle',
            frames: this.anims.generateFrameNumbers('enemy', { start: 0, end: 3 }),
            frameRate: 6,
            repeat: -1,
          });
        }

        if (!this.textures.exists('boss-bull')) {
          const canvas = this.textures.createCanvas('boss-bull', 64, 64);
          const ctx = canvas.getContext();

          // Body
          ctx.fillStyle = '#4a2a2a'; // Dark Iron/Brown
          ctx.beginPath();
          ctx.arc(32, 36, 28, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.stroke();

          // Horns
          ctx.fillStyle = '#e0e0e0';
          ctx.beginPath();
          ctx.moveTo(10, 20); ctx.lineTo(0, 0); ctx.lineTo(24, 14); // Left
          ctx.moveTo(54, 20); ctx.lineTo(64, 0); ctx.lineTo(40, 14); // Right
          ctx.fill();
          ctx.stroke();

          // Eyes
          ctx.fillStyle = '#ff0000';
          ctx.beginPath();
          ctx.arc(22, 30, 6, 0, Math.PI * 2);
          ctx.arc(42, 30, 6, 0, Math.PI * 2);
          ctx.fill();

          // Ring
          ctx.strokeStyle = '#ffd700';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(32, 50, 6, 0, Math.PI * 2); ctx.stroke();

          canvas.refresh();
        }

        if (!this.textures.exists('shadow')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x000000, 0.25);
          g.fillEllipse(TILE_SIZE / 2, TILE_SIZE / 2, 30, 16);
          g.generateTexture('shadow', TILE_SIZE, TILE_SIZE);
          g.destroy();
        }

        if (!this.textures.exists('bomb')) {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0x0b0f1a, 0.22);
          g.fillEllipse(size / 2, size / 2 + 14, 30, 16);
          g.fillStyle(0x2b2f3a, 1);
          g.fillCircle(size / 2, size / 2 + 2, 14);
          g.fillStyle(0x495062, 1);
          g.fillCircle(size / 2 - 3, size / 2 - 1, 10);
          g.lineStyle(2, 0xcfd6e6, 0.35);
          g.strokeCircle(size / 2, size / 2 + 2, 14);
          g.lineStyle(3, 0xffc04d, 1);
          g.beginPath();
          g.moveTo(size / 2 + 8, size / 2 - 10);
          g.lineTo(size / 2 + 16, size / 2 - 16);
          g.strokePath();
          g.fillStyle(0xff6b4f, 1);
          g.fillCircle(size / 2 + 16, size / 2 - 16, 3);
          g.generateTexture('bomb', size, size);
          g.destroy();
        }

        if (!this.textures.exists('explosion')) {
          const size = TILE_SIZE;
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffd36b, 0.9);
          g.fillCircle(size / 2, size / 2, 10);
          g.fillStyle(0xff6b4f, 0.75);
          g.fillCircle(size / 2, size / 2, 16);
          g.fillStyle(0xffffff, 0.65);
          g.fillCircle(size / 2, size / 2, 6);
          g.generateTexture('explosion', size, size);
          g.destroy();
        }

        if (!this.textures.exists('particle')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xffffff, 1);
          g.fillCircle(4, 4, 4);
          g.generateTexture('particle', 8, 8);
          g.destroy();
        }

        if (!this.textures.exists('powerup-bomb')) {
          const size = TILE_SIZE;
          // Helper to draw background + emoji to a canvas texture
          const createEmojiIcon = (key, bgColor, strokeColor, emoji) => {
            const canvas = this.textures.createCanvas(key, size, size);
            const ctx = canvas.getContext();

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.22)';
            ctx.beginPath();
            ctx.ellipse(size / 2, size / 2 + 14, 13, 7, 0, 0, Math.PI * 2);
            ctx.fill();

            // Box (Rounded Rect via arcTo)
            const x = size / 2 - 14, y = size / 2 - 16, w = 28, h = 28, r = 8;
            ctx.fillStyle = bgColor;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 2;
            ctx.stroke();

            // Emoji
            ctx.font = '22px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.fillText(emoji, size / 2, size / 2 - 2);

            canvas.refresh();
          };

          createEmojiIcon('powerup-bomb', '#2a2a00', '#ffd36b', 'üí£');
          createEmojiIcon('powerup-radius', '#002a3a', '#7ce6ff', 'üí•');
          createEmojiIcon('powerup-speed', '#3a1000', '#ff6b4f', 'üëü');
          createEmojiIcon('powerup-remote', '#2a0a3a', '#d67cff', 'üì°');
        }

        if (!this.textures.exists('debris-1')) {
          const g = this.make.graphics({ x: 0, y: 0, add: false });
          g.fillStyle(0xb3784f, 1);
          g.beginPath();
          g.moveTo(0, 0);
          g.lineTo(6, 2);
          g.lineTo(4, 7);
          g.lineTo(0, 5);
          g.closePath();
          g.fill();
          g.generateTexture('debris-1', 8, 8);
          g.clear();
          g.fillStyle(0x8a5a3c, 1);
          g.fillRect(0, 0, 5, 5);
          g.generateTexture('debris-2', 6, 6);
          g.destroy();
        }

        if (!this.textures.exists('soft-glow')) {
          const size = 64;
          const canvas = this.textures.createCanvas('soft-glow', size, size);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
          grad.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
          grad.addColorStop(0.4, 'rgba(255, 255, 255, 0.1)');
          grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, size, size);
          canvas.refresh();
        }

        if (!this.textures.exists('vignette')) {
          const w = WORLD_W;
          const h = WORLD_H;
          const canvas = this.textures.createCanvas('vignette', w, h);
          const ctx = canvas.getContext();
          const grad = ctx.createRadialGradient(w / 2, h / 2, w * 0.35, w / 2, h / 2, w * 0.85);
          grad.addColorStop(0, 'rgba(0,0,0,0)');
          grad.addColorStop(1, 'rgba(0,2,10,0.6)');
          ctx.fillStyle = grad;
          ctx.fillRect(0, 0, w, h);
          canvas.refresh();
        }
      }
    }

    class UIScene extends Phaser.Scene {
      constructor() {
        super({ key: 'UIScene' });
      }

      create() {
        this.score = 0;
        this.lives = 3;
        this.localMp = false;

        // --- Top Bar Panel (Covers Top Wall Row 0 - Height 48px) ---
        this.panel = this.add.rectangle(0, 0, WORLD_W, TILE_SIZE, 0x0b0f1a, 0.95).setOrigin(0, 0);
        this.panel.setStrokeStyle(1, 0x3e4f73);

        // Score (Left)
        this.scoreText = this.add.text(16, 24, 'üèÜ 0', { fontSize: '18px', color: '#eaf2ff', fontStyle: '800' }).setOrigin(0, 0.5);

        // Lives (Left-Center)
        this.livesText = this.add.text(140, 24, '‚ù§Ô∏è 3', { fontSize: '16px', color: '#ff6b6b', fontStyle: 'bold' }).setOrigin(0, 0.5);

        // Stats Icons (Centered Robustly)
        // Total Width of Stats = 50*3 + 20*2 = 190px.
        // Screen Center = WORLD_W / 2.
        // Start X = Center - (190 / 2) = Center - 95.
        const statsStartX = (WORLD_W / 2) - 85;
        this.statsContainer = this.add.container(statsStartX, 24);

        // Bomb Pill
        const bg1 = this.add.rectangle(0, 0, 50, 24, 0x2a2a00, 0.6).setStrokeStyle(1, 0xffd36b, 0.4);
        const bIcon = this.add.image(-12, 0, 'powerup-bomb').setScale(0.35);
        this.statBomb = this.add.text(10, 0, '1', { fontSize: '13px', color: '#ffd36b', fontStyle: 'bold' }).setOrigin(0.5);
        this.statsContainer.add([bg1, bIcon, this.statBomb]);

        // Radius Pill
        const bg2 = this.add.rectangle(70, 0, 50, 24, 0x002a3a, 0.6).setStrokeStyle(1, 0x7ce6ff, 0.4);
        const rIcon = this.add.image(58, 0, 'powerup-radius').setScale(0.35);
        this.statRadius = this.add.text(80, 0, '2', { fontSize: '13px', color: '#7ce6ff', fontStyle: 'bold' }).setOrigin(0.5);
        this.statsContainer.add([bg2, rIcon, this.statRadius]);

        // Speed Pill
        const bg3 = this.add.rectangle(140, 0, 50, 24, 0x3a1000, 0.6).setStrokeStyle(1, 0xff6b4f, 0.4);
        const sIcon = this.add.image(128, 0, 'powerup-speed').setScale(0.35);
        this.statSpeed = this.add.text(150, 0, '1', { fontSize: '13px', color: '#ff6b4f', fontStyle: 'bold' }).setOrigin(0.5);
        this.statsContainer.add([bg3, sIcon, this.statSpeed]);

        // --- Right Side Buttons ---

        // --- Right Side Icon Buttons ---
        let bx = WORLD_W - 24;

        const createBtn = (icon, color, cb) => {
          const btn = this.add.rectangle(bx, 24, 32, 32, 0x2a354c).setStrokeStyle(1, color);
          const txt = this.add.text(bx, 24, icon, { fontSize: '16px', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5);
          btn.setInteractive({ useHandCursor: true })
            .on('pointerdown', cb)
            .on('pointerover', () => btn.setFillStyle(color, 0.5))
            .on('pointerout', () => this.updateBtnState());
          bx -= 38;
          return { btn, txt, color };
        };

        this.btnHelp = createBtn('?', 0xffffff, () => this.toggleHelp());
        this.btnRestart = createBtn('‚Üª', 0xffd36b, () => this.restartGame());
        this.btn1P = createBtn('1P', 0x55ff55, () => this.startSinglePlayer());
        this.btnPvP = createBtn('2P', 0x7cdaff, () => this.startMultiplayer());
        this.btnUnfair = createBtn('‚ò†', 0xff4f4f, () => this.startUnfairGame());

        this.updateBtnState = () => {
          const INACTIVE_BG = 0x2a354c;
          const ACTIVE_TEXT = '#000000';
          const INACTIVE_TEXT = '#ffffff';

          // Reset All
          [this.btnHelp, this.btnRestart, this.btn1P, this.btnPvP, this.btnUnfair].forEach(b => {
            b.btn.setFillStyle(INACTIVE_BG);
            b.txt.setColor(INACTIVE_TEXT);
          });

          const gs = this.scene.get('GameScene');
          const isUnfair = gs ? gs.isUnfair : false;

          if (this.localMp) {
            // PvP Active
            this.btnPvP.btn.setFillStyle(0x7cdaff);
            this.btnPvP.txt.setColor(ACTIVE_TEXT);
          } else if (isUnfair) {
            // Unfair Active
            this.btnUnfair.btn.setFillStyle(0xff4f4f);
            this.btnUnfair.txt.setColor(ACTIVE_TEXT);
          } else {
            // 1P Active (Default)
            this.btn1P.btn.setFillStyle(0x55ff55);
            this.btn1P.txt.setColor(ACTIVE_TEXT);
          }
        };

        // Initial State Update
        this.updateBtnState();

        // Listen for Game Events
        this.game.events.on('ui:update', (data) => this.applyUi(data), this);
        this.events.on('shutdown', () => this.game.events.off('ui:update'));

        const gs = this.scene.get('GameScene');
        if (gs && gs.emitUiState) gs.emitUiState();
      }

      startSinglePlayer() {
        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { localMp: false, level: 1, unfair: false });
        this.applyUi({ score: 0, lives: 3, maxBombs: 1, blastRadius: 2, speed: 120, localMp: false });
      }

      startMultiplayer() {
        if (window.innerWidth < 850) {
          this.showToast("PvP requires a larger screen!");
          return;
        }
        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { localMp: true, level: 1, unfair: false });
        this.applyUi({ score: 0, lives: 3, livesP2: 3, maxBombs: 1, blastRadius: 2, speed: 120, localMp: true });
      }

      startUnfairGame() {
        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { unfair: true, localMp: false, level: 1 });
        this.applyUi({ score: 0, lives: 3, maxBombs: 1, blastRadius: 2, speed: 120, localMp: false });
      }

      createHelpModal() {
        this.helpGroup = this.add.group();
        const ov = this.add.rectangle(WORLD_W / 2, WORLD_H / 2, WORLD_W, WORLD_H, 0x000000, 0.85).setInteractive();

        const pW = 400, pH = 340;
        const panel = this.add.rectangle(WORLD_W / 2, WORLD_H / 2, pW, pH, 0x141a2a).setStrokeStyle(2, 0x3e4f73);

        const cx = WORLD_W / 2, cy = WORLD_H / 2 - pH / 2 + 20;

        this.helpGroup.add(ov);
        this.helpGroup.add(panel);

        const styleH = { fontSize: '18px', color: '#ffd36b', fontStyle: 'bold' };
        this.helpGroup.add(this.add.text(cx, cy, 'HOW TO PLAY', styleH).setOrigin(0.5));

        // Single Player
        this.helpGroup.add(this.add.text(cx, cy + 40, 'SINGLE PLAYER', { fontSize: '12px', color: '#8d9ebf' }).setOrigin(0.5));
        this.helpGroup.add(this.add.text(cx, cy + 60, 'Move: WASD or Arrows   Bomb: SPACE', { fontSize: '14px', color: '#ffffff' }).setOrigin(0.5));

        // PvP
        this.helpGroup.add(this.add.text(cx, cy + 100, 'LOCAL PvP', { fontSize: '12px', color: '#8d9ebf' }).setOrigin(0.5));
        this.helpGroup.add(this.add.text(cx, cy + 120, 'P1 (Blue): WASD + SPACE\nP2 (Red): ARROWS + ENTER', { fontSize: '14px', color: '#ffffff', align: 'center' }).setOrigin(0.5, 0));

        // Powerups
        this.helpGroup.add(this.add.text(cx, cy + 160, 'POWER-UPS', { fontSize: '11px', color: '#8d9ebf' }).setOrigin(0.5));

        const py = cy + 190;
        this.helpGroup.add(this.add.image(cx - 100, py, 'powerup-bomb').setScale(0.6));
        this.helpGroup.add(this.add.text(cx - 75, py - 8, '+ Bomb', { fontSize: '12px' }));

        this.helpGroup.add(this.add.image(cx, py, 'powerup-radius').setScale(0.6));
        this.helpGroup.add(this.add.text(cx + 25, py - 8, '+ Radius', { fontSize: '12px' }));

        this.helpGroup.add(this.add.image(cx + 100, py, 'powerup-speed').setScale(0.6));
        this.helpGroup.add(this.add.text(cx + 125, py - 8, '+ Speed', { fontSize: '12px' }));

        this.helpGroup.add(this.add.text(cx, cy + 280, 'Click anywhere to close', { fontSize: '12px', color: '#fff', alpha: 0.5 }).setOrigin(0.5));

        ov.on('pointerdown', () => this.toggleHelp());
        this.helpGroup.setVisible(false);
        this.isHelpOpen = false;
        this.helpGroup.setDepth(100);
      }

      toggleHelp() {
        this.isHelpOpen = !this.isHelpOpen;
        this.helpGroup.setVisible(this.isHelpOpen);
        if (this.isHelpOpen) this.scene.bringToTop('UIScene');
      }

      applyUi(payload) {
        // Only update mode if explicitly provided
        if (payload.localMp !== undefined) {
          this.localMp = payload.localMp;
          this.updateBtnState();
        }

        // Cache lives locally for partial updates
        if (payload.lives !== undefined) this.lives = payload.lives;
        if (payload.livesP2 !== undefined) this.livesP2 = payload.livesP2;

        // Render based on current persistent mode
        if (this.localMp) {
          this.livesText.setText(`‚ù§Ô∏è${this.lives} üíô${this.livesP2 || 3}`);
          this.statsContainer.setVisible(false);
        } else {
          this.livesText.setText(`‚ù§Ô∏è ${this.lives}`);
          this.statsContainer.setVisible(true);
        }

        if (payload.score !== undefined) this.scoreText.setText(`üèÜ ${payload.score}`);

        // Update Stats if present
        if (payload.maxBombs !== undefined) this.statBomb.setText(payload.maxBombs);
        if (payload.blastRadius !== undefined) this.statRadius.setText(payload.blastRadius);
        if (payload.speed !== undefined) {
          const speedLvl = Math.max(1, Math.round((120 - payload.speed) / 10) + 1);
          this.statSpeed.setText(speedLvl);
        }
      }

      restartGame() {
        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { localMp: false });
        this.applyUi({ score: 0, lives: 3, maxBombs: 1, blastRadius: 2, speed: 120, localMp: false });
      }

      startMultiplayer() {
        if (window.innerWidth < 850) {
          this.showToast("PvP requires a larger screen!");
          return;
        }
        if (this.scene.isActive('GameScene')) this.scene.stop('GameScene');
        this.scene.start('GameScene', { localMp: true });
        this.applyUi({ score: 0, lives: 3, livesP2: 3, localMp: true });
      }
      showToast(msg) {
        const cx = WORLD_W / 2;
        const cy = WORLD_H / 2;
        const bg = this.add.rectangle(cx, cy, 440, 60, 0x000000, 0.85).setDepth(5000);
        bg.setStrokeStyle(2, 0xff4f4f);
        const txt = this.add.text(cx, cy, msg, { fontSize: '18px', color: '#ffffff', fontStyle: 'bold' }).setOrigin(0.5).setDepth(5001);

        this.tweens.add({
          targets: [bg, txt],
          alpha: 0,
          duration: 500,
          delay: 2500,
          onComplete: () => { bg.destroy(); txt.destroy(); }
        });
      }
    }

    function getGameParentSize() {
      const el = document.getElementById('game-container');
      const rect = el.getBoundingClientRect();
      return { width: Math.max(1, Math.floor(rect.width)), height: Math.max(1, Math.floor(rect.height)) };
    }

    const initialSize = getGameParentSize();

    const config = {
      type: Phaser.AUTO,
      parent: 'game-container',
      backgroundColor: '#000000',
      physics: {
        default: 'arcade',
        arcade: {
          gravity: { y: 0 },
          debug: false,
        },
      },
      scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.NO_CENTER,
        width: WORLD_W,
        height: WORLD_H,
      },
      scene: [GameScene, UIScene],
    };

    const game = new Phaser.Game(config);

    // Prevent page scrolling when SPACE is pressed (some browsers still scroll even if Phaser captures).
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') e.preventDefault();
    }, { passive: false });

    // Document-level SPACE fallback (helps when embedded previews/IDEs swallow key events).
    document.addEventListener('keydown', (e) => {
      const isSpace = (e.code === 'Space') || (e.key === ' ') || (e.key === 'Spacebar');
      if (!isSpace) return;
      e.preventDefault();
      if (typeof window.__bmPlaceBomb === 'function') window.__bmPlaceBomb();
    }, { passive: false });

    function handleResize() {
      // Phaser FIT will re-fit into the parent automatically, but it needs a scale refresh.
      if (!game || !game.scale) return;
      game.scale.refresh();
    }

    window.addEventListener('resize', handleResize);
    window.addEventListener('orientationchange', handleResize);

    // Mobile Controls Logic
    document.querySelectorAll('#mobile-controls [data-key]').forEach(el => {
      const key = el.getAttribute('data-key');

      const press = (e) => {
        e.preventDefault(); // Prevent text selection/ghost clicks
        el.classList.add('active');
        if (window.updateBmInput) window.updateBmInput(key, true);
      };
      const release = (e) => {
        e.preventDefault();
        el.classList.remove('active');
        if (window.updateBmInput) window.updateBmInput(key, false);
      };

      el.addEventListener('mousedown', press);
      el.addEventListener('touchstart', press, { passive: false });

      el.addEventListener('mouseup', release);
      el.addEventListener('mouseleave', release);
      el.addEventListener('touchend', release);
      el.addEventListener('touchend', release);
    });

    // Swap Controls Logic
    const swapBtn = document.getElementById('swap-btn');
    const controls = document.getElementById('mobile-controls');

    // Load saved pref
    if (localStorage.getItem('bm_swap') === 'true') {
      controls.classList.add('flipped');
    }

    swapBtn.addEventListener('click', () => {
      controls.classList.toggle('flipped');
      localStorage.setItem('bm_swap', controls.classList.contains('flipped'));
    });
  </script>
</body>

</html>